<style>
  h2 {
    counter-increment:count1;
    counter-reset:count2;
  }
  h2:before {
    content:"2." counter(count1) " ";
  }

  h3 {
    counter-increment:count2;
  }
  h3:before {
    content:"2." counter(count1) "." counter(count2) " ";
  }
</style>

<div style="font-size:25px;font-weight:bold;padding:10px;">第２章 日本語CSVファイル処理</div>

<div class="chapter">
<div class="chapter_description">
  <div class="chapter_description_left">
    <!-- <img width="65" src="images/kaeru_w_01.png"> -->
  </div>
  <div class="chapter_description_right" style="padding:10px;">
    日本語CSVファイル処理をサンプルを使って解説していくよ。Perlでテキスト処理を行うための、print文、文字列、変数、配列、ハッシュ、条件分岐、繰り返し、ファイル入出力、日本語処理といった基本的な文法も解説するね。  </div>
</div>

<h2>日本語CSVファイル処理のプログラム</h2>

CSVとは、カンマで区切られたデータ形式のことです。

<pre>
ID,書名,著者名,価格
1,Perlテキスト処理プログラミング入門,木本裕紀,2900
2,Perl Web開発入門,木本裕紀,2000
3,データベース入門,田中太郎,1900
4,正規表現テクニック,田中太郎,3000
</pre>

CSV形式は、実務でもよく使われ、基本的な学習にぴったりなデータ形式です。ファイルに記述されたこのようなカンマ区切りのCSVデータを、プログラムで処理できるようになることが、この章の目標です。

ではさっそく、日本語CSVファイル処理を行うプログラムをPerlで書いて実行してみましょう。

<h3>CSV形式の入力データファイル</h3>

まず最初に、CSV形式の入力データファイルを作成してみましょう。ファイル名は「tut_input.csv」にします。

<pre>
ID,書名,著者名,価格
1,Perlテキスト処理プログラミング入門,木本裕紀,2900
2,Perl Web開発入門,木本裕紀,2000
3,データベース入門,田中太郎,1900
4,正規表現テクニック,田中太郎,3000
</pre>

文字コードはUTF-8で保存します。エディタによって若干違いがあるのですが、ファイル保存するダイアログの下の方に「文字コード」という項目があると思います。ファイルを保存する前に、この部分で「UTF-8」を指定すると、UTF-8で保存できます。

UTF-8は、ユニコードと呼ばれる文字体系のひとつの符号化方式で、Webにおけるデータ交換用の文字コードとして広く使われています。

<h3>CSVファイル処理の内容</h3>

CSVファイルを入力で受け取って、プログラムで処理をします。どんな処理をするかを、ここで書き出してみます。

・入力データ「tut_input.csv」を読み込む
・田中さんの書籍だけを取り出す
・書名に含まれる「入門」という言葉を「基礎」に変換する
・「tut_output.csv」という名前のファイルに出力

上記の処理を行ったら出力ファイル「tut_output.csv」には、どのような内容が出力されるか、想像してみてください。

<h3>予想される出力データ</h3>

予想される出力データは以下のようになります。

<pre>
3,データベース基礎,田中次郎,1900
4,正規表現テクニック,田中次郎,3000
</pre>

出力ファイルには、田中さんの書籍だけが含まれています。「データベース入門」は「データベース基礎」に変換されています。

<h3>日本語CSVファイル処理するPerlプログラム</h3>

日本語CSVファイル処理するPerlプログラムです。ファイル名は「tut_example1.pl」です。Perlプログラムの文字コードはUTF-8で保存します。

少し長いですが、頑張って書いてみましょう。基本的な内容が詰まったプログラムです。

<pre>
use strict;
use warnings;
use utf8;
use Encode 'encode', 'decode';

# 引数に指定したファイルから行を一行ずつ読み込む
while (my $line = <>) {
  
  # PerlのUTF-8を内部文字列へデコード
  $line = decode('UTF-8', $line);
  
  # 改行を削除
  chomp $line;
  
  # カンマで分割して配列へ
  my @items = split(/,/, $line);
  
  # 本の情報をハッシュへ保存
  my %book;
  $book{id} = $items[0];
  $book{name} = $items[1];
  $book{author} = $items[2];
  $book{price} = $items[3];
  
  # 著者名に田中が含まれていたら
  if ($book{author} =~ /田中/) {
    
    # 書名の入門を基礎に置換
    $book{name} =~ s/入門/基礎/;
    
    # 出力するための配列を作成
    my @output_items = (
      $book{id},
      $book{name},
      $book{author},
      $book{price}
    );
    
    # 出力行を作成
    my $output_line = join(',', @output_items);
    
    # Perlの内部文字列をUTF-8にエンコードして出力
    print encode('UTF-8', $output_line) . "\n";
  }
}
</pre>

Perlのプログラムを次のように実行してみましょう。perlコマンドの第一引数に「プログラム名」、第二引数に「入力ファイル名」を指定します。出力ファイルは、リダイレクト記号「>」の後ろに記述します。

<pre>
perl tut_example1.pl tut_input.csv > tut_output.csv
</pre>

うまくプログラムが実行できましたか? 出力ファイルが、予想した出力と合っているか確認してみましょう。慣れてくるまで、何度かプログラムを書いてみましょう。

では、ここから、このプログラムを理解するための、解説を行っていきます。

<h2>画面に文字列を表示する</h2>

まず最初に、プログラミングのABCである「Hello World!」を画面に表示してみましょう。

画面に文字を表示するには、print文を使います。「Hello World」という文字列を表現するにはダブルクォート「"」で文字「Hello World」を囲みます。文字の並びをプログラミングでは、文字列といいます。Perlプログラムの文の最後はセミコロン「;」で終わります。

<pre>
print "Hello World";
</pre>

これを「hello.pl」という名前で保存してください。

プログラミングを実行するには、perlコマンドを使用します。

<pre>
perl hello.pl
</pre>

画面に以下のように表示されます。

<pre>
Hello World
</pre>

「Hello World!」の後ろで改行されずに、何か文字が続いていると思います。これは、文字列の最後に改行がないためです。改行については、この後で、解説します。

<h2>Perlの文法チェック</h2>

「-c」オプションを使うと、Perlの文法チェックだけを行うことができます。プログラムは実行されません。Perlの文法チェックだけを先に行いたいときに便利です。

<pre>
perl -c hello.pl
</pre>

「syntax OK」と表示されれば、Perlの文法が正しいことが確認できます。

<pre>
hello.pl syntax OK
</pre>

<h2>改行</h2>

Perlプログラムで改行をするには「/n」を使います。「/」はバックスラッシュですが、Windows環境であれば円マーク「&yen;」になっています。

<pre>
print "Hello World\n";
</pre>

このようなバックスラッシュで始まる特殊な文字をエスケープシーケンスといいます。ダブルクォート「"」で囲まれた文字列の中で「\n」と書くと改行を意味し、これはエスケープシーケンスのひとつです。

これを「hello_newline.pl」という名前で保存してください。

プログラミングを実行するには、perlコマンドを使用します。

<pre>
perl hello_newline.pl
</pre>

画面に以下のように表示されます。文字列の末尾で改行されています。

<pre>
Hello World
</pre>

<h2>コメント</h2>

Perlのコメントについて解説します。

<h3>1行コメント</h3>

Perlのコメントは「#」で始まります。コメントは、プログラムとして意味をもちません。

<pre>
# コメント
</pre>

プログラムには、他の人が読むことを想定して、意図を表現した、わかりやすく、短いコメントをつけるのがお勧めです。以下は、コメントの例です。

<pre>
# foo.comのアクセス回数をカウントする
my $accesss_count = 0;
if ($line =~ /foo\.com/) {
  $access_count++;
}
</pre>

<h3>複数行コメント</h3>

Perlには複数行コメントの文法が存在しませんが、ドキュメントを記述するPODと呼ばれる記法を使うと、複数行コメントが書けます。

<pre>
=pod

コメントにしたい文章
コメントにしたい文章

=cut
</pre>

一時的に、プログラムの一部をコメントしたい場合に便利です。

<h2>Perlの約束事</h2>

Perlの約束事です。Perlプログラムの先頭には、文法チェックを厳格にし、警告を表示するように、以下の二行を追加します。

<pre>
use strict;
use warnings;
</pre>

「use strict」の代表的な効果としては、変数宣言がされていない場合に、コンパイルが失敗します。

「use warnings」の代表的な効果としては、未定義値が意図しない場所で利用されていた場合に、警告が発生します。

<h2>変数</h2>

変数について解説します。

<h3>変数宣言</h3>

変数とは、値を保存しておく箱のようなものです。Perlの変数はmyを使って宣言します。変数名の先頭はドル「$」で始まります。

<pre>
# 変数宣言
my $num;
</pre>

「$」で始まる変数名は、正式にはスカラ変数と呼ばれます。スカラ変数は、一つの値を代入できる変数のことです。Perlには、配列変数とハッシュ変数と呼ばれるものがありますが、それは後で解説します。

<h3>有効な変数名</h3>

変数名は、小文字、大文字、数字、アンダースコア「_」で構成することができます。変数名の先頭は数字以外で始まる必要があります。

<pre>
# 有効な変数名
my $book_name;
my $BOOK;
my $author2;
</pre>

<h3>推奨される変数名</h3>

Perlの慣習として、推奨される変数名は、小文字とアンダースコア「_」で構成されるスネークケースと呼ばれる表現です。慣習的に広く利用されている書き方と同じ書き方をしておくと、他の人が読みやすくなるというメリットがあります。

<pre>
# Perlの慣習として推奨される変数名
my $num;
my $book_name;
my $access_count;

# Perlの慣習として推奨されない変数名
my $Num;
my $BookName;
my $AccessCount;
</pre>

変数名の付け方のコツは「他の変数と区別ができること」と「わかりやすく意味のある名前を付けること」です。変数がプログラムを解説してくれて、簡単なコメントがあれば、プログラムが読めるというのが、良いですね。

<h3>変数の宣言と初期化を同時に行う</h3>

変数の宣言と初期化を同時に行うことができます。

<pre>
# 変数の宣言と初期化を同時に行う
my $num = 1;
</pre>

<h2>数値</h2>

数値の表現について解説します。

<h3>整数リテラル</h3>

整数リテラルを使って整数を表現できます。整数リテラルは、ソースコード上での整数の表現です。

<pre>
# 整数リテラル
234
3987
</pre>

整数リテラルでは、アンダースコアを桁区切りとして利用することもできます。

<pre>
# 整数リテラル(桁区切りあり)
100_000_000
4_432_000
</pre>

整数リテラルは、スカラ変数に代入できます。

<pre>
# 数値リテラルを変数に代入
my $num = 234;
my $num = 100_000_000;
</pre>

<h3>浮動小数点リテラル</h3>

浮動小数点リテラルを使って浮動小数点を表現できます。浮動小数点リテラルは、ソースコード上での浮動小数点の表現です。

<pre>
# 浮動小数点リテラル
1.234
12.65
</pre>

浮動小数点リテラルは、スカラ変数に代入できます。

<pre>
# 浮動小数点リテラルを変数に代入
my $num = 12.65;
</pre>

Perlの数値は、プログラムの表現上は、64bit浮動小数点として扱われると考えてください。整数の場合は内部的には最適化のために整数として保持されるという場合があるのですが、プログラムからみた場合は、Perlの数値は、64bit浮動小数点と考えてください。

<h3>数値の計算</h3>

Perlで数値の計算を行ってみます。足し算「+」、引き算「-」、掛け算「*」、割り算「/」の計算です。

<pre>
# 足し算 結果は2
my $add = 1 + 1;

# 割り算 結果は2
my $subtract = 3 - 1;

# 掛け算 結果は6
my $multiply = 3 * 2;

# 割り算 結果は0.5
my $division = 1 / 2;
</pre>

余りと商の求め方を紹介しておきます。商を求めるには普通の割り算を行った後に、int関数で整数部を取り出します。

<pre>
# 商 結果は2
my $div = int(5/2);

# 余り 結果は1
my $mod = 5 % 2;
</pre>

<h3>演算子の優先順位</h3>

演算子の優先順位は「掛け算、割り算」が「足し算、引き算」に優先します。

<pre>
# 掛け算が優先 結果は17
my $num = 2 + 3 * 5;
</pre>

優先順位を変えたい場合や、はっきりさせたい場合は、丸かっこを使います。

<pre>
# 丸かっこが優先 結果は25
my $num = (2 + 3) * 5;
</pre>

<h3>数値計算のサンプルプログラム</h3>

数値計算を使ったサンプルプログラム「calculate.pl」です。数値を変数に保存して、四則演算を行っています。Perlでプログラムを書く場合は、「use strict;」「use warnings;」を先頭に書きましょう。

<pre>
use strict;
use warnings;

# 数値を計算する
my $num1 = 1 + 2 * 3;
my $num2 = 4 * 5;
my $num3 = $num1 + $num2;

print "$num3\n";
</pre>

実行してみましょう。

<pre>
perl calculate.pl
</pre>

出力結果です。計算結果が出力されます。

<pre>
27
</pre>

<h2>文字列</h2>

文字列について解説します。文字列とは、文字の並びを意味します。文字列は、シングルクォート「'」で囲む方法と、ダブルクォート「"」で囲む方法の二種類の表現方法があります。

<h3>シングルクォート文字列</h3>

シングルクォート文字列は、文字列を単なる文字列として、扱いたい場合に使います。

<pre>
# シングルクォートで囲った文字列
'Hello';
</pre>

シングルクォート文字列は、スカラ変数に代入できます。

<pre>
my $message = 'Hello';
</pre>

<h3>ダブルクォート文字列</h3>

ダブルクォートを使って、文字列を表現できます。

<pre>
# ダブルクォートで囲った文字列
"Hello";
</pre>

ダブルクォート文字列は、スカラ変数に代入できます。

<pre>
my $message = "Hello";
</pre>

ダブルクォートで囲った文字列の中では、エスケープシーケンスと変数展開を使うことができます。

<h4>エスケープシーケンス</h4>

エスケープシーケンスとは、改行「\n」やタブ「\t」などの特別な文字のことです。

<pre>
# タブと改行をエスケープシーケンスで表現
my $message = "Foo\tBar\n";
</pre>

<h4>変数展開</h4>

変数展開とは、変数の内容が文字列として展開される機能のことです。

<pre>
my $name = 'mojigaeru';

# 変数展開が行われる「I am mojigaeru」となる
my $message = "I am $name";
</pre>
 
<h3>文字列の連結</h3>

文字列を連結するには、文字列連結演算子「.」を使用します。

<pre>
# 「abcdef」になる
my $concat = 'abc' . 'def';
</pre>

<h3>文字列のサンプルプログラム</h3>

文字列を使ったサンプルプログラムです。

数値計算を使ったサンプルプログラム「string.pl」です。文字列を連結して表示するサンプルです。Perlでプログラムを書く場合は、「use strict;」「use warnings;」を先頭に書きましょう。

<pre>
use strict;
use warnings;

# 変数展開を使ってメッセージを作成
my $fruit0 = 'orange';
my $fruit1 = 'banana';
my $fruit2 = 'apple';
my $message = "I like $fruit0, $fruit1, and $fruit2.";

# メッセージの末尾に新しいメッセージを追加
$message = $message . "Hello!";

# 改行をつけて出力
print $message . "\n";
</pre>

実行してみましょう。

<pre>
perl string.pl
</pre>

出力結果です。メッセージが出力されます。

<pre>
I like orange, banana, and apple.Hello!
</pre>

<h2>配列</h2>

Perlの配列について解説します。

<h3>配列とは</h3>

配列とは、複数の値を代入できる変数のことです。スカラ変数が「$」で始まったのに対して、配列の先頭は「@」で始まります。「$」や「@」のことをシジルと呼びます。

<pre>
# 配列の宣言
my @nums;
</pre>

配列は、リストを使って初期化できます。リストとは「(」と「)」で囲まれた、カンマで区切られた値の並びのことです。

<pre>
# 配列の宣言
my @nums = (5, 4, 3);
</pre>

配列の要素には、文字列を代入することもできます。

<pre>
# 文字列の配列
my @strs = ('foo', 'bar', 'baz');
</pre>

文字列と数値を混在させることもできます。

<pre>
# 数値と文字列が混在した配列
my @items = (1, 2, 'foo', 'bar');
</pre>

Perlは動的型言語なので、配列の要素の型を意識する必要はありません。

<h3>配列の要素の取得と設定</h3>

配列の要素の取得と設定を行うには、以下の構文を使用します。インデックスは0から始まることに注意してください。配列の要素を取得・設定するときは「@」ではなく「$」を使うことに注意してください。

<pre>
# 配列の要素の取得
$配列名[インデックス]

# 配列の要素の設定
$配列名[インデックス] = 値
</pre>

配列の要素の取得と設定を行うサンプルです。

<pre>
# 配列の宣言 インデックスは0から数える
my @nums = (5, 4, 3);

# 配列の要素を取得
my $elem = $nums[2];

# 3
print "$elem\n";

# 配列の要素の設定
$nums[1] = 7;

# 7
print "$nums[1]\n";
</pre>

<h3>配列の要素の画面への出力</h3>

配列の要素を出力してみましょう。変数展開を使うと便利です。配列は変数展開すると、要素が空白で区切られた値に変換されます。

<pre>
# 配列の宣言
my @nums = (5, 4, 3);

print "@nums\n";
</pre>

出力結果は以下のようになります。

<pre>
5 4 3
</pre>

<h2>ハッシュ</h2>

Perlのハッシュについて解説します。Perlのハッシュとは、キーと値の複数のペアを保存できる変数のことです。ソフトウェア用語では、連想配列と呼ばれているものです。

<h3>ハッシュの宣言</h3>

ハッシュの宣言です。ハッシュ名は「%」で始まります。

<pre>
# ハッシュの宣言
my %book;
</pre>

<h3>ハッシュへの代入</h3>

ハッシュにはキーと値のペアが入ったリストを代入することができます。この例では、本という名前のハッシュを宣言して「ID」「書名」「価格」という情報を持たせています。

<pre>
# ハッシュへの代入
%book = (id => 1, name => 'Perl', price => '900');
</pre>

ハッシュの宣言と同時に初期化することもできます。

<pre>
# ハッシュの宣言と同時に初期化
my %book = (id => 1, name => 'Perl', price => '900');
</pre>

Perlでは、「=>」は「,」と同じ意味です。「=>」はファットカンマと呼ばれます。「=>」の左側の文字列は「a-zA-Z0-9_」で構成されている場合は、シングルクォートやダブルクォートを省略できます。

<pre>
# ファットカンマを使ってハッシュの中身を表現
%book = (id => 1, name => 'Perl', price => '900');

# 上記は、以下と同じ意味
%book = ('id', 1, 'name', 'Perl', 'price', '900');
</pre>

<h3>ハッシュの値の取得と設定</h3>

ハッシュの値の取得と設定を行うには、以下の構文を使用します。キー名は文字列です。ハッシュの要素を取得・設定するときは「%」ではなく「$」を使うことに注意してください。

<pre>
# ハッシュの要素の取得
$ハッシュ名{キー名}

# ハッシュの要素の設定
$ハッシュ名{キー名} = 値
</pre>

ハッシュの値の取得と設定のサンプルです。

<pre>
# ハッシュの値の取得
$book{'name'};
$book{'price'};

# ハッシュの値の設定
$book{'name'} = 'Database';
$book{'price'} = 2000;
</pre>

ハッシュのキー名は文字列ですが「a-zA-Z0-9_」で構成されている場合は、シングルクォートやダブルクォートで囲む必要はありません。

<pre>
# ハッシュのキーを、シングルクォートやダブルクォートで囲まない記法
$book{name};
$book{price};
$book{name} = 'Database';
$book{price} = 2000;
</pre>

慣習としては、シングルクォートやダブルクォートで囲まない記法が、多く利用されています。

<h2>if文を使った条件分岐</h2>

条件を指定して、実行する処理を切り替えることを、条件分岐といいます。条件分岐はif文を使って行うことができます。

<h3>本の価格が1000円以下だったら</h3>

本の価格が、1000円以下だったら「Low Price」と画面に出力するというサンプル(if_price_under_1000.pl)を書いてみましょう。

<pre>
use strict;
use warnings;

# 本の価格が1000円以下だったら「Low Price」と画面に出力
my $book_price = 900;

if ($book_price <= 900) {
  print "Low Price\n";
}
</pre>

ifの丸かっこ「()」の中に条件を書くことができます。「<=」は、○○以下を表す数値比較演算子です。条件が真になった場合は、ブロック「{}」の中の処理が実行されます。条件が真というのは、条件が満たされたという意味だと考えてください。

実行してみましょう。

<pre>
perl if_price_under_1000.pl
</pre>

出力結果です。

<pre>
Low Price
</pre>

<h3>数値比較演算子</h3>

数値比較演算子の一覧です。

<table>
  <tr>
    <td>
      <b>演算子</b>
    </td>
    <td>
      <b>意味</b>
    </td>
  </tr>
  <tr>
    <td>
      A == B
    </td>
    <td>
      AとBは等しい
    </td>
  </tr>
  <tr>
    <td>
      A != B
    </td>
    <td>
      AとBは等しくない
    </td>
  </tr>
  <tr>
    <td>
      A > B
    </td>
    <td>
      AはBより大きい
    </td>
  </tr>
  <tr>
    <td>
      A >= B
    </td>
    <td>
      AはB以上
    </td>
  </tr>
  <tr>
    <td>
      A < B
    </td>
    <td>
      AはBより小さい
    </td>
  </tr>
  <tr>
    <td>
      A <= B
    </td>
    <td>
      AはB以下
    </td>
  </tr>
</table>

<h3>本の名前がPerlだったら</h3>

本の名前が「Perl」だったら「Name is Perl」と画面に出力するというサンプル(if_name_eq_perl.pl)を書いてみましょう。

<pre>
use strict;
use warnings;

# 本の名前が「Perl」だったら「Name is Perl」と画面に出力
my $book_name = 'Perl';

if ($book_name eq 'Perl') {
  print "Name is Perl\n";
}
</pre>

「eq」は、文字列が○○と等しいを表す文字列比較演算子です。Perlでは数値比較演算子と文字列比較演算子が区別されているので、注意してください。条件が真になった場合は、ブロック「{}」の中の処理が実行されます。

実行してみましょう。

<pre>
perl if_name_eq_perl.pl
</pre>

出力結果です。

<pre>
Name is Perl
</pre>

<h3>文字列比較演算子</h3>

文字列比較演算子の一覧です。文字列比較演算子において、文字列の大小は、辞書順比較になります。

<table>
  <tr>
    <td>
      <b>演算子</b>
    </td>
    <td>
      <b>意味</b>
    </td>
  </tr>
  <tr>
    <td>
      A eq B
    </td>
    <td>
      AとBは等しい
    </td>
  </tr>
  <tr>
    <td>
      A ne B
    </td>
    <td>
      AとBは等しくない
    </td>
  </tr>
  <tr>
    <td>
      A gt B
    </td>
    <td>
      AはBより大きい
    </td>
  </tr>
  <tr>
    <td>
      A ge B
    </td>
    <td>
      AはB以上
    </td>
  </tr>
  <tr>
    <td>
      A lt B
    </td>
    <td>
      AはBより小さい
    </td>
  </tr>
  <tr>
    <td>
      A le B
    </td>
    <td>
      AはB以下
    </td>
  </tr>
</table>

<h3>本の名前にPerlを含んでいたら</h3>

本の名前にPerlを含んでいたら「This is Perl Book.」と出力するif文を使ったサンプルです。正規表現と呼ばれる文法を使います。
<pre>
use strict;
use warnings;

# 本の価格が1000円以下だったら「Low Price」と画面に出力
my $book_name = 'Perl Tutorial';

if ($book_name =~ /Perl/) {
  print "This is Perl Book.\n";
}
</pre>

「=~」はパターンマッチ演算子と呼ばれ、正規表現にマッチした場合に真になります。

<h2>繰り返し</h2>

Perlの繰り返し処理の解説です。Perlでは、繰り返しを行うときに、for文あるいはwhile文を使います。

<h3>for文</h3>

Perlのfor文は、二種類の構文があります。

<h4>C言語風のfor文</h4>

C言語風のfor文です。繰り返しを行う基本的な構文です。ループ変数の初期化、繰り返し条件、ループ変数の更新を記述します。

<pre>
# for文 - C言語風for文
for (ループ変数の初期化; 繰り返し条件; ループ変数の更新) {
  # 処理
}
</pre>

C言語風のfor文を使ったサンプル「loop_for_c.pl」です。ループ変数を0から始めて、5より小さい間ループします。ループ変数はインクリメントの構文「$i++」を使って、ループが実行されるたびに、1づつ増加させています。

<pre>
use strict;
use warnings;

# for文 - C言語風for文
for (my $i = 0; $i < 5; $i++) {
  print "$i\n";
}
</pre>

実行してみましょう。

<pre>
perl loop_for_c.pl
</pre>

出力結果です。0～4が順番に出力されています。

<pre>
0
1
2
3
4
</pre>

<h4>配列の要素を順番に処理するfor文</h4>

配列を順番に処理するfor文です。

<pre>
# for文 - 配列の要素を順番に処理するfor文
for 要素を代入する変数 (配列) {
  # 処理
}
</pre>

配列の要素を順番に処理するfor文のサンプル「loop_for_iterate.pl」です。

<pre>
use strict;
use warnings;

# for文 - 配列の要素を順番に処理するfor文
my @nums = (4, 6, 9);
for my $num (@nums) {
  print "$num\n";
}
</pre>

実行してみましょう。

<pre>
perl loop_for_iterate.pl
</pre>

出力結果です。配列の要素が順番に出力されています。

<pre>
4
6
9
</pre>

<h3>foreach文</h3>

Perlにはforeach文というものがあるのですが、for文とまったく同じ意味です。

<h3>while文</h3>

while文を使って、ループすることもできます。while文はループの原始的な構文です。while文の丸かっこ「()」の中には条件を書くことができます。while文の条件が真の場合にブロック「{}」の中の処理が実行されます。

<pre>
while (繰り返し条件) {
  # 処理
}
</pre>

while文を使ったループのサンプル「loop_while.pl」です。

<pre>
use strict;
use warnings;

# while文
my $i = 0;
while ($i < 10) {
  # 処理
  print "$i\n";
  
  $i++;
}
</pre>

実行してみましょう。

<pre>
perl loop_while.pl
</pre>

出力結果です。0～4の値が順番に出力されました。

<pre>
0
1
2
3
4
</pre>

<h2>Perl標準関数</h2>

関数の使い方について学びましょう。関数は、特定の機能を便利に使える道具のようなものだと考えてください。Perlには、標準関数と呼ばれる、デフォルトで使える関数が用意されています。

<h3>chomp関数 - 改行削除</h3>

chomp関数は、改行を削除するための関数です。Perlプログラミングでは、ファイルから行を読み込んだときに、まず改行を削除するということを行います。

<pre>
# 改行を削除
chomp $line;
</pre>

Windows、Unix/Linux/Macの場合は、chompで削除される改行コードは「\n」です。

<h3>OSに依存しないで改行コードを削除する方法</h3>

OSに依存しないで改行コードを削除する方法について解説しておきます。この部分は、読み飛ばしてもかまいません。

WindowsとUNIXの改行コードという二つのOSに絞って話をします。LinuxとMacはUNIXをベースにしているので、UNIXであると考えてください。

OSによって異なる改行コードを、Perlは抽象化して扱おうとします。

<h4>Windowsの改行コードとUNIXの改行コード</h4>

Windowsの改行コードはASCIIコードにおける「CRLF」です。

UNIXの改行コードはASCIIコードにおける「LF」です。

テキストファイルを保存した場合は、一般的には、上記の改行コードで保存されます。ただし、異なる改行コードで保存することもできます。UNIXからWindowsへファイルを移動する場合、WindowsからUNIXへファイルを移動する場合は、OSの改行コードと、テキストファイルに含まれる改行コードは、異なってしまいます。

このような場合に、実務として問題になってくるのは、どのようにして改行コードを削除するかということです。

<h4>OSに依存しないで改行コードを削除するコード</h4>

WindowsとUNIXの改行コードの違いに依存しないで、改行コードを削除する正しいコードをここに書きます。正規表現の知識が必要になるので、正規表現の章を読んでから、ここに戻ってきてもよいでしょう。

<pre>
# WindowsとUNIXの改行コードの違いに依存しないで改行コードを削除する
$line =~ s/\x0D?\x0A$//;
</pre>

CRは、ASCIIコードの16進数で「0D」です。LFは、ASCIIコードの16進数で「0A」です。Perlでは「\x0D」のようにエスケープシーケンスを使ってASCIIコードを16進数で表現できます。

正規表現の意味は「末尾のCRLF、または、末尾のLFを削除する」です。この正規表現でWindowsとUNIXの改行コードの違いに依存しないで改行コードを削除することができます。

<h4>CRまたはCRLFを出力する</h4>

print関数で、出力する場合に、改行コードを指定したい場合があります。このような場合は、次のようにします。

<pre>
# LFを出力したい場合
print "$line\x0A";

# CRLFを出力したい場合
print "$line\x0D\x0A";
</pre>

<h3>split関数 - 区切り文字を指定して配列に変換する</h3>

split関数は、指定した区切り文字で対象の文字列を分割し、配列に変換する関数です。split関数の第一引数には、区切り文字を正規表現「//」を指定できます。第二引数には、対象の文字列を指定します。

<pre>
split 区切り文字の正規表現, 文字列
</pre>

split関数のサンプル「split.pl」です。

<pre>
use strict;
use warnings;

# カンマ区切りのデータ
my $csv = '1,Perl,Mojigaeru,2900';

# カンマ区切りのデータを配列に変換
my @items = split(/,/, $csv);

# 配列の内容を出力
for my $item (@items) {
  print "$item\n";
}
</pre>

実行してみましょう。

<pre>
perl split.pl
</pre>

出力結果です。

<pre>
1
Perl
Mojigaeru
2900
</pre>

<h3>join関数 - 区切り文字で連結された文字列を取得</h3>

join関数を使うと、指定した区切り文字で、配列の各要素を連結した文字列を取得できます。join関数の第一引数は、区切り文字です。第二引数以降はリストです。

<pre>
join 区切り文字, リスト
</pre>

join関数のサンプル「join.pl」です。

<pre>
use strict;
use warnings;

# 配列
my @items = (1, 'Perl', 'Mojigaeru', 2900);

# join関数で、カンマで連結してCSVデータに変換
my $csv = join(',', @items);

print "$csv\n";
</pre>

実行してみましょう。

<pre>
perl join.pl
</pre>

出力結果です。

<pre>
1,Perl,Mojigaeru,2900
</pre>

<h2>日本語処理</h2>

Perlで日本語を扱う方法について解説します。

<h3>ソースコードはUTF-8で保存</h3>

Perlで正しく日本語を扱う場合は、ソースコードをUTF-8で保存する必要があります。UTF-8というのは、ユニコードの符号化方式のひとつです。

Windowsのメモ帳の場合は、名前を付けて保存を行うダイアログで「文字コード」を選択できるので「UTF-8」を選択します。他のエディタを使っている場合も、名前を付けて保存のダイアログの下の方に「文字コード」の選択があるので、「UTF-8」を選択します。

<h3>「use utf8;」の記述</h3>

「use utf8;」を記述します。「use utf8;」は、ソースコードがUTF-8で書かれていることをPerlに知らせるためのものです。これを記述することで、Perlは、ソースコードに書かれた文字列を内部的な文字列として扱ってくれます。内部的な文字列を、ここでは、内部文字列と呼ぶことにします。公式には、テキスト文字列と呼ばれ、デコードされた文字列と呼ばれることもあります。

<pre>
use utf8;
</pre>

<h3>Encodeモジュール</h3>

Encodeモジュールは、Perlで内部文字列とバイト文字列の変換を行うためのモジュールです。バイト文字列とは、実際の文字コードで表現されたバイト列のことです。モジュールというのは、プログラムの機能をまとめた部品のようなものだと考えてください。

内部文字列とバイト文字列の変換を行うために、Encodeモジュールのencode関数とdecode関数をインポートしましょう。インポートとは、モジュールで定義された関数を、関数名だけで呼び出せるようにする機能のことです。

<pre>
# Encodeモジュールのencode関数とdecode関数をインポート
use Encode 'encode', 'decode';
</pre>

<h3>ファイルから入力するときはdecode関数</h3>

ファイルから入力するときはdecode関数を使って、実際の文字コードから、Perlの内部文字列へデコードします。たとえば、読み込む対象のファイルがUTF-8で書かれていたら、UTF-8を指定、cp932で書かれていたらcp932を指定します。

<pre>
# 引数に指定したファイルから行を一行ずつ読み込む
while (my $line = <>) {
  
  # PerlのUTF-8を内部文字列へデコード
  $line = decode('UTF-8', $line);
  
  # ...
}
</pre>

Perlでは、日本語は、プログラムの中においては、Perlの内部文字列に変換して扱います。Perlの内部文字列の表現はlatin-1あるいはUTF-8ですが、ここでは、詳細については、忘れてください。decode関数は、実際の文字コードをを、Perlが内部で扱う形式に変換する関数なのだということだけ、理解してください。

内部文字列への変換が行われると、文字列関数や正規表現で、日本語を正しく扱えるようになります。

<h3>ファイルへ出力するときはencode関数</h3>

ファイルへ出力するときは、encode関数を使って、Perlの内部文字列から、実際の文字コードへエンコードします。ファイルへ出力する直前でエンコードします。encode関数は、decode関数と反対の操作です。

<pre>
# Perlの内部文字列をUTF-8にエンコードして出力
print encode('UTF-8', $output_line) . "\n";
</pre>

Perlの日本語処理に対する混乱は、encode関数とdecode関数が、実際の文字コードから、実際の文字コードの変換を行っているように誤解してしまうことにあると思っています。これは、以前に頻繁に利用されていたjcode.plやJcode.pmが、実際の文字コードを、実際の文字コードに変換するライブラリだったからだと思います。

Perl 5.8以降の新しい文字列の扱いは、実際の文字コードを、Perlの内部文字列に変換するという仕組みであることを、しっかりと覚えておいてください。

<h3>日本語を出力するサンプル</h3>

著者名に木本を含んでいたら。「これは木本の著作です」と出力するサンプルです。

<h4>Windowsの場合のサンプル</h4>

Windowsの場合のサンプル「contain_jp_string_win.pl」です。ソースコードは、UTF-8で保存します。

<pre>
use strict;
use warnings;
use utf8;
use Encode 'encode';

# 著者の名前に木本を含んでいたら「これは木本の著作です。」と画面に出力
my $author_name = '木本裕紀';

if ($author_name =~ /木本/) {
  my $message = "これは木本の著作です";
  print encode('cp932', $message) . "\n";
}
</pre>

実行してみましょう。

<pre>
perl contain_jp_string_win.pl
</pre>

出力結果です。

<pre>
これは木本の著作です
</pre>

<h4>Linux/Unix/Macの場合のサンプル</h4>

Linux/Unix/Macの場合のサンプル「contain_jp_string_unix.pl」です。ソースコードは、UTF-8で保存します。

<pre>
use strict;
use warnings;
use utf8;
use Encode 'encode';

# 著者の名前に木本を含んでいたら「これは木本の著作です。」と画面に出力
my $author_name = '木本裕紀';

if ($author_name =~ /木本/) {
  my $message = "これは木本の著作です";
  print encode('UTF-8', $message) . "\n";
}
</pre>

実行してみましょう。

<pre>
perl contain_jp_string_unix.pl
</pre>

出力結果です。

<pre>
これは木本の著作です
</pre>

<h2>ファイル入出力</h2>

ファイル入出力を行う最も簡単な方法を紹介します。

<h3>リダイレクトを使ったファイルへの出力</h3>

ファイルへ出力するには、リダイレクトと呼ばれる方法を使います。リダイレクトを使うと、画面への出力をファイルへの出力に切り替えることができます。リダイレクトは、Perlの機能ではなくコマンドプロンプトやシェルの機能です。

「>」がリダイレクトの記号です。リダイレクトを使って、画面への出力を「tut_output.csv」というファイルへの出力に切り替えています。

<pre>
perl tut_example1.pl tut_input.csv > tut_output.csv
</pre>

<h3>ダイヤモンド演算子を使ったファイルからの入力</h3>

ダイヤモンド演算子「<>」を使うと、コマンドライン引数で指定したファイルから、1行づつ読み込むことができます。ダイヤモンド演算子は通称です。本当の名前は「行入力演算子」です。

<pre>
# 引数に指定したファイルから行を一行ずつ読み込む
while (my $line = <>) {
  
}
</pre>

一行づつ読み込んで、ファイルの末尾に到達すると、ダイヤモンド演算子は偽を返し、whileループは終了します。while文の条件部に「my」を使った変数宣言を書いていますが、Perlの変数宣言は値を返す式なので、このように書けます。

Windowsの場合は、行入力演算子で読み込むと、Windowsの改行コードであるCRLFからPerlでの改行を表現する文字である「\n」に変換されることに注意してください。

コマンドライン引数とは、プログラム名の後ろに続く部分のことです。ここにファイル名を指定します。「tut_input.csv」が、コマンドライン引数です。

<pre>
perl tut_example1.pl tut_input.csv
</pre>

ダイヤモンド演算子を使うと「tut_input.csv」のファイルの内容を一行づつ読み込むことができます。

<h3>一般的なファイル入出力</h3>

Perlには、open関数を使って、ファイル入出力を行う一般的な方法があります。興味のある方は「Perl ファイル入出力」などの用語で検索してみてください。Perlゼミのサイトでも解説しています。

<h2>最初のCSVファイル処理のサンプルをもう一度</h2>

これで最初のサンプル「tut_example1.pl」を理解するためのすべての解説が終わりました。最初のサンプルのソースコードをもう一度読んでみましょう。この章の内容を理解できていれば、読めるようになっていると思います。

次の章では、Perlでテキストを自由に扱えるようになるために、正規表現を使った文字列の検索について解説します。
