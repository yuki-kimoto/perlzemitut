<ol class="bread" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemprop="item" href="/">
        <span itemprop="name">Perl</span></a>
    <meta itemprop="position" content="1" />
  </li>
  &#8250;
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
      <span itemprop="name">正規表現</span>
    <meta itemprop="position" content="2" />
  </li>
</ol>
<h2>Perlの正規表現をマスターしよう</h2>



Perlの<strong>正規表現</strong>の解説です。この記事を読めば、日常で利用する正規表現のすべてを短時間でマスターすることができます。正規表現を使えば、文字列の集合を表現することができ、正規表現にマッチする文字列を検索したり、置換したりすることができます。 　

正規表現を使って文字列の集合を表現できます。たとえば「a」「aa」「aaa」という三つの文字列を正規表現で表現してみましょう。連続する文字の個数を表現する正規表現「{}」を使って次のように書くことができます。

<pre>
a{1,3}
</pre>

「a」「aa」「aaa」という文字列の集合をひとつの正規表現「a{1,3}」で表しています。{}は量指定子と呼ばれるもので、連続した文字を表現することができます。

<pre>
a
aa     ->    a{1,3}
aaa
</pre>

正規表現の例をもう一つみてみましょう。「p1」「q1」「r1」という文字列の集合をひとつの正規表現「[pqr]1」で表すことができます。[]は<a href="/blog/20200114103559.html">文字クラス</a>と呼ばれるもので、複数の文字の集合を表現することができます。

<pre>
p1
q1    ->    [pqr]1
r1
</pre>

このように複数の文字列をひとつの正規表現で書くことができます。

<h3>パターンマッチ</h3>

パターンマッチとは正規表現で表した文字の集合が対象の文字列に含まれているかを調べる操作のことをいいます。パターンマッチを行うにはパターンマッチ演算子を使用します。

<pre>
# パターンマッチ
$str =~ /正規表現/
</pre>

パターンマッチ演算子は「=~」です。正規表現はスラッシュ「/」で囲む必要があります。マッチした場合は真を、マッチしなかった場合は偽を返します。パターンマッチはif文と組み合わせて利用されることがほとんどです。

<pre>
if ($str =~ /正規表現/) {
  # マッチした場合の処理
}
</pre>

「a{1,3}」という正規表現が「This string is aa.」という文字列にパターンマッチするかを確認してみましょう。

<pre>
文字列: 「This string is aa.」

正規表現:  「a{1,3}」
</pre>

スクリプトは以下になります。

<pre>
my $str = 'This string is aa.';

if ($str =~ /a{1,3}/) {
  print "Match\n";
}
</pre>

「Match!」と出力されます。

反対にパターンマッチしないということを表す演算子「!~」もあります。

<pre>
$str !~ /正規表現/
</pre>

<h4>マッチした文字列を取得する</h4>

パターンマッチを使って、マッチした文字列を取得することができます。マッチした文字列を取得するには取得したい部分を「()」で囲みます。「This string is aar1」という文字列の中の「aa」と「r1」を取得してみましょう。

<pre>
文字列: 「This string is aar1」

正規表現:  (a{1,3})([pqr]1)
</pre>

スクリプトは次のようになります。<a href="/blog/20161102147817.html">特殊変数</a>「$1」と「$2」には括弧で囲んだ部分が順番に代入されます。

<pre>
my $str = 'This string is aar1';
if ($str =~ /(a{1,3})([pqr]1)/) {
  print "Get $1 and $2";
}
</pre>

次のように出力されます。
<pre>
Get aa and r1
</pre>

また文字列を「This string is aaap1」に変更してみましょう。次のように出力されます。

<pre>
Get aaa and p1
</pre>

<h3>置換</h3>

正規表現を使ってマッチした文字列を置換することができます。置換の構文は次のようになります。

<pre>
対象文字列 =~ s/正規表現/置換後の文字列/;
</pre>

では「This string is aa」という文字列を「This string is bb」という文字列に置換してみましょう。このサンプルではaaにマッチする正規表現「a{1,3}」を使用します。

<pre>
正規表現                      置換後の文字列
a{1,3}                --->    bb

対象文字列                    
This string is aa     --->    This string is bb
</pre>

スクリプトは次のようになります。

<pre>
my $str = 'This string is aa';
$str =~ s/a{1,3}/bb/;
</pre>

置換されるのはひとつだけです。たとえば「This string is aa aaa」という文字列があれば、上記の置換では「This string is bb aaa」となり、マッチした最初の文字列だけが置換されます。

すべてのマッチ文字列を置換するには正規表現オプション「g」を使用します。正規表現のオプションは末尾に指定します。

<pre>
# マッチしたすべての文字列を置換
対象文字列 =~ s/正規表現/置換後の文字列/g;
</pre>

すべてのマッチした文字列を置換するスクリプトは次のようになります。

<pre>
my $str = 'This string is aa aaa';
$str =~ s/a{1,3}/bb/g;
</pre>

置換後の文字列を出力すると次のようになります。

<pre>
This string is bb bb
</pre>

ではここからさまざまな正規表現を見ていきましょう。

<h3>正規表現文字</h3>

文字の集合を表す正規表現には次のようなものがあります。

<table>
  <tr>
    <td>
      .
    </td>
    <td>
      改行を除くすべての文字
    </td>
  </tr>

  <tr>
    <td>
      \d
    </td>
    <td>
      数字
    </td>
  </tr>

  <tr>
    <td>
      \D
    </td>
    <td>
      数字以外の文字
    </td>
  </tr>

  <tr>
    <td>
      \w
    </td>
    <td>
      ワード文字(「a～z」「A～Z」「0～9」 アンダーバー「_」)
    </td>
  </tr>

  <tr>
    <td>
      \W
    </td>
    <td>
      ワード文字以外の文字
    </td>
  </tr>

  <tr>
    <td>
      \s
    </td>
    <td>
      空白文字( スペース「 」、タブ文字「\t」、改行文字「\n, \r」など)
    </td>
  </tr>

  <tr>
    <td>
      \S
    </td>
    <td>
      空白文字以外の文字
    </td>
  </tr>

  <tr>
    <td>
      ^
    </td>
    <td>
      文字列の先頭
    </td>
  </tr>

  <tr>
    <td>
      $
    </td>
    <td>
      文字列の末尾
    </td>
  </tr>

  <tr>
    <td>
      \b
    </td>
    <td>
      ワード文字の境界
    </td>
  </tr>

</table>

<h4>改行を除く任意の一文字「.」</h4>

改行を除く任意の一文字を表現するには「.」を使用します。

<pre>
a
b
c    ->    .
)
@
</pre>

「.」を改行を含む任意の文字にマッチさせることもできます。「.」を改行にマッチさせたい場合は、正規表現オプション「s」を使用します。

<pre>
# .を改行を含む任意の文字にマッチさせる
$str =~ /./s;
</pre>

<h4>数字「\d」</h4>

数字を表現するには「\d」を使用します。0～9にマッチします。

<pre>
0
1
2    ->    \d
8
9
</pre>

<h4>数字以外「\D」</h4>

数字以外の文字を表現するには「\D」を使用します。これは「\d」と対になるものです。

<pre>
数字「\d」以外    ->    \D
</pre>

<h4>空白文字「\s」</h4>

空白文字とはスペース、タブ、改ページ、キャリッジリターン、ラインフィードのことです。空白文字を表現するには「\s」を使用します。

<pre>
スペース 「 」
タブ 「\t」
改ページ 「\f」           ->    \s
キャリッジリターン「\n」
ラインフィード「\r」
</pre>

<h4>空白文字以外「\S」</h4>

空白文字以外の文字を表現するには「\S」を使用します。これは「\s」と対になるものです。

<pre>
空白文字「\s」以外    ->    \S
</pre>

<h4>ワード文字「\w」</h4>

ワード文字とは「アルファベットと数字とアンダーバー」の集合のことを指します。ワード文字を表現するには「\w」を使用します。

<pre>
A-Z
a-z
       ->    \w
0-9
_
</pre>

<h4>ワード文字以外「\W」</h4>

ワード文字以外の文字を表現するには「\W」を使用します。

<pre>
ワード文字「\w」以外    ->    \W
</pre>

<h4>文字列の先頭「^」</h4>

正規表現文字には文字の先頭を表現できるものがあります。文字の先頭を表現するには「^」を使用します。

<pre>
文字列の先頭    ->    ^
</pre>

この正規表現文字は文字の長さを持ちません。他の文字と組み合わせて利用します。たとえば「^abc」という正規表現は先頭が「abc」で始まる文字列にマッチします。「abc」が含まれていても先頭が「abc」でなければマッチしません。

<pre>
abcppp
abcqqq    ->    ^abc
abcrrr
</pre>

^はmオプションと組み合わせた場合は行の先頭という意味に変わります。mオプションを使用した場合に文字列の先頭を表現したい場合は「\A」を使用します。「\A」はオプションの存在にかかわらず常に文字列の先頭を表現します。

<h4>文字列の末尾「$」</h4>

文字列の末尾を表現するには「$」を使用します。たとえば「abc$」という正規表現は末尾が「abc」で終わる文字列にマッチします。

<pre>
pppabc
qqqabc    ->    abc$
rrrabc
</pre>

$はmオプションと組み合わせた場合は行の末尾という意味に変わります。mオプションを使用した場合に文字列の末尾を表現したい場合は「\z」を使用します。「\z」はオプションの存在にかかわらず常に文字列の末尾を表現します。

<h4>ワード文字の境界</h4>

ワード文字の境界を表現するには「\b」を使用します。ワード文字の境界とはワード文字からそれ以外の文字へと変わっている部分のことを指します。たとえば「abc\b」という正規表現は「abcd」にはマッチしませんが「abc/」や「abc@」や「abc 」にはマッチします。

<pre>
abc/
abc@    ->    abc\b
abc 
</pre>

<h3>文字クラス</h3>

複数の文字の集合を表現するには<a href="/blog/20200114103559.html">文字クラス</a>を使用します。

<pre>
[文字の集合]
</pre>

たとえば「a」か「b」か「c」という文字を表現したい場合は[abc]と書きます。

<pre>
a
b    ->    [abc]
c
</pre>

アルファベットの範囲や数値の範囲を指定するのにハイフン「-」記号を使用することができます。

<pre>
a
b
c    ->    [a-e]
d
e
</pre>

<pre>
0
1
2    ->    [0-4]
3
4
</pre>

アルファベットと数値のいずれかを表現したい場合は[a-zA-Z0-9]と書きます。

<pre>
アルファベットと数字    ->    [a-zA-Z0-9]
</pre>

文字クラスを使って特定の文字以外を表現することもできます。特定の文字以外を表現するには「^」を使用します。文字クラス[]の先頭で「^」が使用されると「それ以外」という意味になり、「文字の先頭」という意味にはならないので注意してください。

たとえば「a」「b」「c」以外の文字を表現するには次のようにします。

<pre>
「a」「b」「c」以外の文字    ->    [^abc]
</pre>

<h3>量指定子</h3>

ある文字が連続していくつ続くかを量指定子を使って指定することができます。量指定子には次のものがあります。

<table>
  <tr>
    <td>
      ?
    </td>
    <td>
      直前の文字が0個か1個
    </td>
  </tr>

  <tr>
    <td>
       *
    </td>
    <td>
      直前の文字が0個以上
    </td>
  </tr>

  <tr>
    <td>
      +
    </td>
    <td>
      直前の文字が1個以上
    </td>
  </tr>

  <tr>
    <td>
      {m,n}
    </td>
    <td>
      直前の文字がm個以上n個以下
    </td>
  </tr>

  <tr>
    <td>
      {m,}
    </td>
    <td>
      直前の文字がm個以上
    </td>
  </tr>

  <tr>
    <td>
      {0,n}
    </td>
    <td>
      直前の文字がn個以下
    </td>
  </tr>

</table>

<h4>? 直前の文字が0個か1個</h4>

?は直前の文字が0個か1個ということを表現する量指定子です。わかりやすく言い換えれば「直前の文字があってもなくてもよい」ということです。

<pre>
aaap
        ->    aaap?
aaa
</pre>

量指定子はもちろん正規表現文字と組み合わせて使用することもできます。

<pre>
aaa
aaap
        ->    aaa[pqr]?
aaaq
aaar
</pre>

<h4> * 直前の文字が0個以上</h4>

*は直前の文字が0個以上ということを表現する量指定子です。

<pre>
aaa
aaap     ->    aaap*
aaapp
</pre>

<h4>+ 直前の文字が1個以上</h4>

+は直前の文字が1個以上ということを表現する量指定子です。

<pre>
aaap
aaapp     ->    aaap+
aaappp
</pre>

<h4>{m,n} 直前の文字がm個以上n個以下</h4>

{m,n}は直前の文字がm個以上n個以下ということを表現する量指定子です。

<pre>
aaap
aaapp     ->    aaap{1,3}
aaappp
</pre>

<h4>{m,}</h4>

{m,}は直前の文字がm個以上ということを表現する量指定子です。

<pre>
aaapp
aaappp     ->    aaap{2,}
aaapppp
</pre>

<h4>{0,n}</h4>

{0,n}は直前の文字がn個以下ということを表現する量指定子です。

<pre>
aaappp
aaapppp     ->    aaap{0,5}
aaappppp
</pre>

<h3>文字列の集合</h3>

文字列の集合を表現するには「|」を使用します。通常は括弧「()」と組み合わせて使用します。

<pre>
a123b
a456b    ->    a(123|456|789)b
a789b
</pre>

<h3>正規表現文字のエスケープ</h3>

正規表現文字を普通の文字として意味させるには直前に\をつける必要があります。たとえば「.」という文字自体を表現するには「\.」とする必要があります。

<pre>
.txt    ->    \.txt
</pre>

<a href="/blog/20100329127089.html">quotemeta関数</a>を使用すると文字列全体に対してエスケープを自動で行ってくれます。

<pre>
my $regex = quotemeta('.txt');
</pre>

エスケープのための\Qという特殊な正規表現文字を使うこともできます。\Qから\Eまでがエスケープされる文字になります。\Eがない場合は正規表現の終わりまでが対象になります。

<pre>
/\Q.txt\E/
</pre>

<h3>正規表現のテクニック</h3>

<h4>(?:) キャプチャしない括弧</h4>

正規表現の括弧「()」にはキャプチャを行うためと「(A|B)」といういうように「または」ということを意味したい場合に利用されます。()を単なる「または」のために使うためには「()」の代わりに「(?:)」を使うことができます。

<pre>
(?:A|B)
</pre>

<h4>正規表現の囲み文字の変更</h4>

正規表現の中でスラッシュがたくさん出てくる場合は、\でエスケープしなければいけないのでとても面倒です。そのような場合はmを直前に置いて正規表現の囲み文字を変更することができます。

<pre>
/\/aaa\/bbb/

# 上記と意味
m#/aaa/bbb#
m{/aaa/bbb}
</pre>

置換の場合も囲み文字を変更することができます。

<pre>
s#aaa#bbb#
s|aaa|bbb|
</pre>

<h4>正規表現のリファレンス</h4>

正規表現は<a href="/blog/20080419120860.html">qr演算子</a>を使ってリファレンスにすることができます。正規表現のリファレンスにすれば、正規表現オプションを含めて変数に代入することができます。

<pre>
my $regex = qr/(\d+)/sm;
</pre>

これは通常のパタンマッチでも利用することができます。

<pre>
my $num = 34;
if ($num =~ /$regex/) {
   
}
</pre>

<h3>正規表現のオプション</h3>

正規表現には必要に応じてオプションを指定することができます。

<table>
  <tr>
    <td>
      g
    </td>
    <td>
      パターンマッチを繰り返す
    </td>
  </tr>

  <tr>
    <td>
      s
    </td>
    <td>
      「.」を改行にマッチさせる
    </td>
  </tr>

  <tr>
    <td>
      m
    </td>
    <td>
      「^」と「$」を行の先頭と末尾にマッチさせる
    </td>
  </tr>

  <tr>
    <td>
      i
    </td>
    <td>
      大文字と小文字を区別しないでマッチさせる
    </td>
  </tr>

  <tr>
    <td>
      e
    </td>
    <td>
      置換に式を利用する
    </td>
  </tr>

  <tr>
    <td>
      x
    </td>
    <td>
      正規表現内のスペースを無視する
    </td>
  </tr>

  <tr>
    <td>
      o
    </td>
    <td>
      変数展開を一度だけ行う
    </td>
  </tr>

</table>

正規表現のオプションは正規表現の末尾で指定します。複数のオプションを組み合わせることも可能です。

<pre>
/正規表現/sm
</pre>

<h4>g マッチしたすべての文字列を置換する</h4>

gオプションを指定することで、マッチしたすべてのものを置換することができます。

<blockquote>
$message2 =~ s/yah/yes/g;
</blockquote>

mとsとgについてはすでに解説したので残りのオプションを解説します。

<h4>m「^」と「$」を行の先頭と末尾にマッチさせる</h4>

「<strong>m</strong>」オプションを使用すれば、「^」と「$」を行の先頭と末尾にマッチさせることができます。

<pre>
$message =~ /^i/m
</pre>

<h4>s 「.」を改行にマッチさせる sオプション</h4>

「<strong>s</strong>」オプションを使用すれば、「改行」を「.」にマッチさせることができます。

<pre>
$message =~ /^i/s
</pre>

<h4>i 大文字と小文字を区別しないでマッチさせる</h4>

iオプションを使用すると大文字と小文字を区別しないでマッチさせることができます。

<pre>
abc
Abc    ->    /abc/i
ABC
</pre>

<h4>e 置換に式を利用する</h4>

eオプションを使用すると置換の結果に式を使用することができます。

次のサンプルはマッチした数値を2倍するサンプルです。

<pre>
s/(\d+)/$1 * 2/e;
</pre>

<h4>x 正規表現内の空白を無視する</h4>

xオプションを使うと正規表現内の空白を無視することができます。またコメントを記述することができるようになります。スペースであることが重要でない場合は、xオプションを使うと正規表現を見やすく記述することができます。

<pre>
my $time = '03:02:56';
my $regex = qr/
  (\d{2}) # 時
  :
  (\d{2}) # 分
  :
  (\d{2}) # 秒
/x;

if ($time =~ /$regex/) {
  my $hour   = $1;
  my $minute = $2;
  my $second = $3;
}
</pre>

空白自体を使用したい場合は「\ 」のように空白をエスケープします。

<h4>o 変数展開を一度だけ行う</h4>

正規表現オプション「o」を使えば、変数展開を一度だけ行うようになります。これは、正規表現の再評価が行われないので、パフォーマンスが増しますが、バグの原因にもなりやすいので、必要に応じて利用しましょう。

<pre>
my $regex = "a pen";
for (1 .. 10) {
  $message =~ /$regex/o;
}
</pre>

o オプションを使うと、変数展開が、最初の一度だけ行われます。つまり、ループの2回目からは、 /$regex/ → /a pen/ という変数展開が行われずに、 /a pen/ が、そのまま使われるということです。

<h3>最短マッチ</h3>

Perlの正規表現にはひとつの癖があります。それは量指定子が一番長い位置でマッチするということです。たとえば次の正規表現と文字列が与えられたときどの部分にマッチするでしょうか。

<pre>
# 正規表現
.+\s

# 文字列
aaa bbb ccc
</pre>

.+\sという正規表現の意味は「改行以外の文字がひとつ以上で空白」という意味です。上のサンプルでは複数の候補があります。「aaa 」と「aaa bbb 」というふたつの候補です。Perlのデフォルトの動作では一番長い位置にマッチし「aaa bbb 」にマッチします。

<pre>
# マッチする文字列
「aaa bbb 」
</pre>

これを「aaa 」にマッチさせることは可能です。このテクニックを最短マッチといいます。最短マッチを行うには量指定子の後ろに?を付けます。正規表現を (.+?\s) にすれば、「aaa 」にマッチするようになります。

<pre>
# 最短マッチを行う正規表現
.+?\s
</pre>

これで「aaa 」に正規表現がマッチするようになります。

<pre>
「aaa 」
</pre>

<h3>日本語と正規表現</h3>

正規表現の中で日本語を使うためには正規表現も対象の文字列も内部文字列に変換しておく必要があります。内部文字列への変換は<a href="/blog/20091118124667.html">Encodeモジュールの使い方</a>で解説していますので参考にしてください。

<h3>終わりに</h3>

この解説で学んだことさえ覚えておけば実務で困ることはないでしょう。正規表現を使えば必要な行だけを抜き出したり、簡単に置換することができるます。Perlの醍醐味である正規表現をぜひ楽しんでみてください。


