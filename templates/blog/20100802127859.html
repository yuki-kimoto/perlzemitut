<ol class="bread" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemprop="item" href="/">
        <span itemprop="name">Perl</span></a>
    <meta itemprop="position" content="1" />
  </li>
  &#8250;
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
      <span itemprop="name">豆知識</span>
    <meta itemprop="position" content="2" />
  </li>
</ol>
<h2>豆知識 - 知っておくと役に立つ</h2>



知っておくと何かとPerlが使いやすくなったり、読みやすくなるかもしれないことをいろいろと追加していきます。

<h3>BEGIN</h3>

BEGINはコンパイルのときに実行するということをあらわします。

<pre>
BEGIN {
  # コンパイルのときに実行したい文
}
</pre>

<h3>require</h3>

requireはuseと似ていますが実行時にモジュールを読み込むことと、importメソッドを自動的に実行しないところがことなります。

<pre>
use File::Basename 'basename';

# 上と同じ意味
BEGIN {
  require File::Basename;
  File::Basename->import('basename');
}
</pre>

動的にモジュールを読み込みたい場合はrequireを使用することがありますが、一般的な用途ではuseで統一するのがわかりやすいでしょう。

<h3>local</h3>

localはローカル変数を生成するためのものではありません。localは値を一時的に変更してスコープを抜けた段階で値を復元するためのものです。なぜかmyで宣言されたスカラ変数自体には利用することはできません。使用できるのはパッケージ変数とハッシュの要素、配列の要素などです。

<pre>
our $num = 1;
{
  # 一時的に変更
  local $num = 2;
}

# 1に戻る
print $foo;

my $scores = {math => 90, english => 100};
{
  # 一時的に変更
  local $scores->{math} = 80;
}

# 90に戻る
print $scores->{math};
</pre>

けれどもlocalはよほど特殊な用途でない限りは使う場面はありません。ほぼすべての場面でmyですんでしまうので、まずmyで済ませられないかどうかを真剣に検討しましょう。

localについての詳しい解説は以下を参考にしてください。

<ul>
  <li>
    <a href="/blog/20080309120507.html">local - パッケージ変数を一時的に退避して復元</a>
  </li>
</ul>

<h3>複数行コメント</h3>

複数行コメントの構文はないので、少し残念ですがコメントは#のみになります。デバッグ中に複数行コメントをしたい場合は、ドキュメントとして解釈させることで、コメントアウトすることができます。

<pre>
=pod

my $str = 'aaa';
my $foo = 'foo';

=cut
</pre>

「=pod」「=cut」として囲まれた部分はドキュメントと解釈され無視されます。

<h3>シジルが異なれば別の変数</h3>

シジルが異なればまったく別の変数です。

<pre>
# 配列
my @ids;

# スカラ
my $ids;
</pre>
上記の変数はidsという名前を持ちますが、まったく別の変数になります。

<h3>特殊変数の意味を調べる</h3>

特殊変数はgoogleの検索ではとても探しにくくて苦労します。またドキュメントから探すのも面倒です。perldocコマンドの「-v」オプションを使用すると、英語ですが、特殊変数の意味を知ることができます。

<pre>
perldoc -v $.
</pre>

<h3>メソッド呼び出し</h3>

Perlでは->を使ってメソッド呼び出しを行うことができます。
<pre>
# メソッド呼び出し
SomeClass->method('a', 'b');
$obj->method('a', 'b');
</pre>

メソッド呼び出しが関数呼び出しと異なるのはサブルーチンの第一引数に->の左側の値が渡されるということです。上記の例ではmethodの第一引数はSomeClassという文字列あるいは$objになります。'a', 'b'は第二引数、第三引数になります。

受け取る側は次のように記述します。
<pre>
# クラスメソッドの場合
sub method {
  my ($class, $arg1, $arg2) = @_;
}

# オブジェクトメソッドの場合
sub method {
  my ($self, $arg1, $arg2) = @_;
}
</pre>

<h3>ミニperldocガイド</h3>

perldocコマンドでPerlのドキュメントを見ることができます。

<pre>
perldoc perlfunc
</pre>

モジュールのドキュメントも見ることができます。

<pre>
perldoc File::Basename
</pre>

モジュールの中身を見たい場合はmオプションを指定します。

<pre>
perldoc -m File::Basename
</pre>

モジュールのパスを知りたいときはlオプションを指定します。

<pre>
perldoc -l File::Basename
</pre>

標準関数のドキュメントを見たい場合はfオプションを指定します。

<pre>
perldoc -f substr
</pre>

リダイレクトしてファイルに落とすと見るのが楽です。

<pre>
perldoc File::Basename > File-Basename.txt
</pre>

<h3>無名サブルーチン</h3>

Perlではsub { } を使うことで無名サブルーチンを作成することができます。

<pre>
my $twice = sub {
  my $num = shift;

  return $num * 2;
}
</pre>

実行するには次のようにします。

<pre>
my $result = $twice->(5);
</pre>

<h3>デリファレンスの{}の省略</h3>

デリファレンスの記号{}は省略することも可能です。

<pre>
my @array = @$array_ref;

# 以下と同じ意味
my @array = @{$array_ref};
</pre>

単純な変数でない場合は{}が必要です。

<pre>
my @array = @{$var->nums};
</pre>

<h3>ファイル演算子のドキュメントの見方</h3>

-sや-fなどのファイル演算子はよく使用しますが、どうやってドキュメントを見たらよいかがわかりにくいです。コマンドラインで次のようにします。

<pre>
perldoc -f -X
</pre>

<h3>文字の置換 tr</h3>

trというのを時々みるかもしれませんが、tr演算子は文字列の置換を行います。以下の文は「a ⇒ 1」「b ⇒ 2」「c ⇒ 3」という置換を行います。

<pre>
$str =~ tr/abc/123/;
</pre>

<h3>Perl自体の設定を見る</h3>

コマンドライン引数で

<pre>
perl -V
</pre>

とします。

<h3>ハッシュのリファレンスのハッシュスライス</h3>

ハッシュのリファレンスをデリファレンスしてハッシュスライスする記法はとても読みにくいです。

<pre>
my ($key1, $key2, $key3) = @{$hash}{qw/key1 key2 key3/};
</pre>

できればひとつづつ代入するほうがよいと思います。

<pre>
my $key1 = $hash->{key1};
my $key2 = $hash->{key2};
my $key3 = $hash->{key3};
</pre>

<h3>evalのある使い方</h3>

<pre>
eval { 実行文; 1; } or die "Exception";
</pre>

という記述は良く見かけますが、少し読みにくいです。これの意味はまず<a href="/blog/20100312126967.html">eval</a>は{}の中が正常であった場合は最後の実行文の結果を返却します。つまり、1を返却します。この場合はorの右辺は実行されません。失敗した場合はundefを返します。この場合は右辺は実行されます。1;とわざわざ書くのは実行文の戻り値が0で合った場合は成功していても右辺が実行されてしまうからです。

<pre>
eval { 実行文 };
die "Exception" if $@;
</pre>
のほうが好みです。

<h3>よく使用する特殊変数</h3>
<ul>
  <li>
    @_ - サブルーチンの引数
  </li>
  <li>
    @ARGV - コマンドライン引数
  </li>
  <li>
    $. - ファイルを読み込んだ場合の行番号
  </li>
  <li>
    $0 - スクリプト名
  </li>
  <li>
    $1 - 正規表現の括弧()にマッチした部分。$2, $3 も同じ意味
  </li>
  <li>
    $! - OSのエラーメッセージ
  </li>
  <li>
    $@ - evalで例外をキャッチした場合の例外メッセージ
  </li>
  <li>
    $? - 子プロセスのステータス
  </li>
</ul>

<h3>shift関数のデフォルト引数</h3>

shift関数で引数を指定しなかった場合、トップレベルであれば引数はコマンドライン引数(@ARGV)、サブルーチンの中であればサブルーチンの引数(@_)になります。単独のshiftはよく使われます。

<pre>
# トップレベル
my $num = shift;

# 以下と同じ意味
my $num = shift @ARGV; 
</pre>

<pre>
# サブルーチンの中
sub {
  my $num = shift;
  
  # 以下と同じ意味
  my $num = shift @_;
}
</pre>

<h3>外部プロセスの終了ステータス</h3>

system関数などで外部プロセスを呼び出したとき、外部プロセスの終了ステータスは$?という特殊変数の上位8bitの中に入っています。コマンドの呼び出し自体が失敗した場合は$?に-1が設定されます。ですから、終了ステータスが正常(0であれば正常)であることを調べるには次のようにします。

<pre>
my $command = "ls -l";
system $command;

if ($? == -1) {
  die "failed to execute: $!\n";
}
elsif ($? >> 8 != 0) {
  die "Return error status\n";
}
</pre>

<h3>Perlのithreadの実装はあまりよくない</h3>

Perlではithreadと呼ばれる軽量スレッドの実装がありますが、あまり実装がよろしくないといううわさです。またCPANモジュールはスレッドセーフであることを意識して作成されていないので、思わぬバグに突き当たります。またネイティブスレッドはサポートしていません。自動的にスレッドを切り替える処理はPerlで書くのはあきらめたほうが無難でしょう。

自分でスレッドを切り替える用途であればコルーチンであるCoroが使えるでしょう。

<h3>古典Perl</h3>

書くときは使わないですが、読むときに古典的な文法に遭遇するかもしれません。

varsプラグマは、ourで宣言したのと同じ効果をもちます。
<pre>
# our $VAR; と同じ
use vars 'VAR'; 
</pre>

<h3>覚えておきたいqで始まる演算子</h3>

  qで始まる演算子は覚えにくいのでまとめておきます。また囲む文字には//や{}や##や||などを使うことができます。

qはシングルクォート演算子です。シングルクォートが使える以外はシングルクォートと同じです。

<pre>
my $str = q/aaa ''' bbb/;
</pre>

qqはダブルクォート演算子です。ダブルクォートが使える以外はダブルクォートと同じです。

<pre>
my $str = qq/aaa """ $str/;
</pre>

qwは文字列リスト演算子です。文字列のリストを簡単に書くことができます。
<pre>
# ('foo', 'bar', 'baz') と同じ
my $str = qw/foo bar baz/ 
</pre>

qrは正規表現のリファレンスです。
<pre>
my $regex_ref = qr/^aaa.*bbb$/ms;
</pre>

<h3>モジュールの末尾には1;が必要</h3>

モジュールの末尾には1;が必要です。1でなくても真の値であれば何でもかまいませんが、普通は1;を使います。
<pre>
package SomeModule;

# 実装

1;
</pre>

<h3>ブロックの最後にはセミコロンは不要。評価が最後の場合はreturnは不要。</h3>

ブロックの最後であればセミコロンはあってもなくてもかまいません。

<pre>
sub func1 {
  my $arg = shift;

  # このセミコロンはあってもなくてもよい。
  return $arg; 
}
</pre>

また戻り値はそれが最後の評価になる場合はreturnが必要ではありません。

<pre>
sub func1 {
  my $arg = shift;

  # returnは合ってもなくてもよい。
  $arg; 
}
</pre>

通常はreturnもセミコロンもつけておいたほうがよいでしょう。関数を一行で書く場合はセミコロンもreturnも使わないほうがきれいに書けることが多いようです。

<pre>
# 定数など
sub CONST_VALUE { 3 }
</pre>

<h3>たくさんPerlを試したいとき</h3>

わたしはどこかで見つけたサンプルを実行したい場合はa.plという簡単なファイルを用意して、そこで実験するようにしています。削除するのも面倒なので、新しく実験したい場合は「__END__」を使えば、スクリプトはそこで終了とみなされます。

<pre>
perl a.pl
</pre>

<pre>
use strict;
use warnings;

print 'aaa';

__END__

print 'bbb';
</pre>

<h3>デバッガで最終行を実行したときにプログラムを終わらせない</h3>

Perlのデバッガを使ったときに最終行を実行するとプログラムが終わってしまうのを避けたい場合は次のように意味のない「1;」という実行文を最終行に入れます。

<pre>
my $str = 'aaa';
print $str;

1;
</pre>

<h3>ファイル読込のショートカット</h3>

使い捨てのスクリプトを作成する場合は、ファイルオープンの記述を行うのは少し面倒です。ダイヤモンド演算子を単独で使えば、コマンドライン引数、あるいは標準入力から1行づつファイルの読込ができます。

<pre>
# コマンドライン
perl script.pl file1 file2
</pre>

<pre>
# ファイルから1行づつ読み込み
while (my $line = <>) {
  ...
}
</pre>

この記述は
<pre>
while (defined(my $line = <>)) {
  ...
}
</pre>

と同じ意味を持つので0だけが含まれる行なども、正しく読み込んでくれるので安心です。

<h3>変数展開の注意</h3>

変数名の後にコロンやアンダーバーが続いていると正しく変数展開を行うことができません。そのような場合は「{}」でくくって明示的に変数名を示します。

<pre>
my $name = 'aaa';
my $message = "${name}::aaa ${name}_ppp";
</pre>

<h3>シンボルテーブルを覗いてみる</h3>

変数やサブルーチンなどの名前が登録されているデータ構造です。各パッケージのシンボルは「::」をパッケージ名の末尾に付けた変数に格納されています。

<pre>
# シンボルテーブル
%main::
%CGI::
%File::Basename::
</pre>

<h3>each関数はwhileの中だけで使う</h3>

each関数は内部的にイテレータを持っているので、一度だけ使うとイテレータが進んだままになってしまいます。

<pre>
# イテレータが進んだままになってしまう。
my ($key, $value) = each %hash;
</pre>
keys関数を作用させるとイテレータはリセットされますが、あまり良い方法ではないでしょう。

<pre>
# イテレータのリセット
keys %hash;
</pre>

each関数はwhileループの中でだけ利用しましょう。

<pre>
while(my ($key, $value) = each %hash) {
  ...
}
</pre>

<h3>print関数に渡すファイルハンドルは第一引数ではない</h3>

変な仕様です。print関数に渡すファイルハンドルは第一引数ではないです。ファイルハンドルの後ろにはカンマがありません。

<pre>
# $fhは第一引数ではない。
print $fh $output;
</pre>
これは間接オブジェクト記法と呼ばれ次と同じ意味を持ちます。

<pre>
$fh->print($output);
</pre>

<h3>WindowsではIO::Pollやselectはソケットに対してしかうまくいかない</h3>

Windowsでは非同期IO処理はソケットに対してしか行うことができません。ファイルに対してはできません。

<h3>Windowsではglob関数の引数に空白が含まれているとうまく動かない</h3>

Windowsではglob関数の引数に空白が含まれているとうまく動きません。なんとかこれをうまくいかせるには、ダブルクォートで囲む必要があります。

<pre>
my @files = glob('"C:/Documents and Settings/*.*"');
</pre>

<h3>サブルーチンの括弧が必要な場合</h3>

サブルーチンがすでに宣言されていれば括弧はいりません。

<pre>
# すでにサブルーチンが宣言されている場合は括弧がいらない。
sub func1 { print $_[0] }
func1 'aaaa';
</pre>

インポートした場合も同じです。

<pre>
# インポートした場合も括弧はいらない
use Carp 'croak';

croak 'aaa';
</pre>

後ろで宣言されている場合は括弧が必要です。

<pre>
# 後ろで宣言されている場合は括弧が必要
func1('aaa');
sub func1 { print 1 }
</pre>

<h3>無名サブルーチンは最初から最後まで存在する</h3>

動的に作成したように見える無名サブルーチンはプログラムの最初にコンパイルされて、プログラムの最後に破棄されます。次のコードで生成されるのはサブルーチンのリファレンスであって、サブルーチンそのものではないです。ごちゃまぜになりやすいので注意。

<pre>
{
  # 生成されるのはサブルーチンのリファレンスでサブルーチンそのものではない
  my $sub = sub {
    ...
  }
}
</pre>

<h3>正規表現でのリストコンテキスト</h3>

<a href="/blog/20100827127859.html">正規表現</a>を使ってマッチした文字の一部分を取得したい場合はif文と組み合わせて次のように書きます。

<pre>
if ($str =~ /正規表現/) {
  my $match1 = $1;
  my $match2 = $2;
}
</pre>

もうひとつ書き方があって、正規表現をリストコンテキストで評価してマッチした文字を取得することもできます。

<pre>
my ($match1, $match2) = $str =~ /正規表現/;
</pre>

<h3>正規表現の囲み文字の変更</h3>

通常は正規表現は次のように書きます。

<pre>
$str =~ /正規表現/
</pre>

もうひとつ同じ意味を持つ書き方があります。mを使って上記と同じ意味になります。

<pre>
$str =~ m/正規表現/;
</pre>

これは何のためにあるかというと正規表現の中で「/」がたくさん出てくる場合にエスケープするのはとても見にくくなると思った場合に正規表現の囲み文字を変えることができます。囲み文字を「#」に変更した例です。

<pre>
$str =~ m#http://aaa.com#;
</pre>

<h3>ord関数はordinalの略</h3>

文字列を渡すとコードポイントを返却してくれるord関数はordinalの略。これは日本語に訳すと序数という意味。ちなみに対になっているchr関数はコードポイントを渡すと文字に変換してくれます。

<pre>
ord関数 <-> chr関数
</pre>

<h3>orは「左辺が真でなければ」と英文的に読みます。</h3>

orはもともと論理演算子なのですが、論理演算子としては使われずに条件分岐に使われることがほとんどです。

<pre>
A or B
</pre>

Perlのor演算子は左辺(A)が真であった場合は、右辺(B)の結果がどうであろうと「A or B」は真になるので、右辺を実行しないという特徴があります。条件分岐に利用される場合はこの特徴が利用されています。

つまり左辺(A)が真の場合には右辺(B)は実行されす、左辺(A)が偽の場合は右辺(B)が実行されます。英文的に読むと「左辺(A)が真でなければ右辺(B)を実効する」と読めます。

<h3>設定ファイルをPerlで記述する</h3>

設定ファイルはPerlで記述するのが便利です。設定ファイルを読み込むには<a href="/blog/20090208123289.html">do</a>を使用します。 

<pre>
my $conf_file = "app.conf";
my $conf = do $conf_file
  or die qq/Can't load config file "$conf_file": $!$@/;
</pre>

設定ファイルの内容です。

<pre>
{
  name => 'Foo',
  number => 9
}
</pre>

ファイルの読み込みか解析に成功しなかった場合は未定義値が返却されます。ファイル名が存在しなかった場合は$!に、Perlのソースコードの読み込みに失敗した場合は$@にエラーの内容が設定されます。

なぜか今までわたしはXMLとかJSONで設定ファイルを書いていましたが、よく考えるとPerlで書くのが一番楽ですね。

注意点ですが、自分の手で書いた設定ファイル以外をdoで読み込んではいけません。さもなければ任意のスクリプトが実行されてしまう危険があるからです。

