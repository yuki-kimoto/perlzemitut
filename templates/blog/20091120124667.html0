<ol class="bread" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemprop="item" href="/">
        <span itemprop="name">Perl</span></a>
    <meta itemprop="position" content="1" />
  </li>
  &#8250;
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <span itemprop="name">here</span>
  </li>
</ol>
<h2>現代的なPerlの記述方法一覧</h2>



Perl5.8以降における標準的なPerlの書き方を解説します。

<img style="border:1px solid #ddd" src="https://cdn-ak.f.st-hatena.com/images/fotolife/p/perlcodesample/20180905/20180905152847.png">

インターネットで検索するとPerl4のころの古い記述がたくさんあります。また書籍などの多くもPerl4の記法で書かれています。Perl4の記法は複雑になりやすく間違いを生みやすいのでこれからPerlを書く人はPerl5の現代的な記法で記述することを強くお勧めします。 

<h3>strictプラグマとwarningsプラグマ (必須)</h3>

strictプラグマとwarningsプラグマを有効にします。

<pre>
use strict;
use warnings;
</pre>

use strict;とuse warnings;の２行はスクリプトの最初に必ず記述してください。これらはPerlの文法チェックを厳しくするためのものです。面倒だという軽い気持ちでこれを記述しないと後々本当に面倒なことになります。

use strict;とuse warningsを書かなくてもよいのはワンライナーと呼ばれるコマンドラインスクリプトを記述するときだけだという風に考えてください。

<h3>ファイルハンドルにはレキシカル変数を使うこと (本当に特別な用途がない限りは必須)</h3>

ファイルハンドルには宣言したばかりのレキシカル変数を使います。レキシカル変数を宣言してそれをopen関数の第1引数に指定するとレキシカル変数にファイルハンドルが設定されます。

<pre>
# レキシカル変数
my $fh;
my $file = 'file1';

open $fh, '<', $file
  or die "Cannot open '$file': $!";

while (my $lien = <$fh>) {
  ...
}
</pre>

レキシカル変数はスコープを持つということと他の関数に引数として渡すことができるという大きな利点があります。古い解説にあるようなFHや*FHなどのシンボルを使わないようにします。

またレキシカル変数の宣言をopen関数の中にまとめてしまうのがより現代的であるといえるでしょう。

<pre>
open my $fh, '<', $file
</pre>

<h3>3引数のopen関数を使う (必須)</h3>

3引数のopen関数を使用するようにします。
<pre>
open my $fh, '<', $file
</pre>

古い解説では2引数のopen関数を解説しているものがありますが使わないようにしましょう。2引数のopen関数はセキュリティ的に脆いので使用してはいけません。

<pre>
open my $fh, "< $file"; # 2引数のopen関数を使用してはいけない
</pre>

これはパイプをオープンするときにも当てはまります。

<pre>
# ○ (三引数)
open my $pipe, '-|', 'dir';

# × (二引数)
open my $pipe, 'dir |';
</pre>

<h3>ファイルオープン時のエラー処理を行う (必須)</h3>

ファイルオープンを行ったときは必ずエラー処理を行うようにします。

<pre>
open my $fh, '<', $file
  or die "Cannot open '$file': $!";
</pre>

open関数は失敗するとundefを返すのでorを使ってエラー処理を行います。$!にはOSが返したエラーメッセージが含まれているのでユーザに見せるエラーメッセージに含めるようにします。

プログラムをエラーメッセージを表示して終了させるにはdie関数を使用します。他のプログラムから見た場合は終了コードは255になります。

ファイルオープンに限らずプログラムの外部と通信する場合はかならずエラー処理を行うようにします。外部というのはメモリの操作を除くすべてです。ファイルやネットワークなどが外部になります。

<h3>レキシカル変数とサブルーチンの名前には小文字とアンダーバーを使用する (強く推奨)</h3>

「myで宣言されるレキシカル変数」と「サブルーチン」の名前には小文字とアンダーバーを使用します。

<pre>
# レキシカル変数
my $user_name;
my $search_word;
my $max_database_connection;

# サブルーチン
sub parse_data {
  ...
}

sub create_table {
  ...
}
</pre>

この記法が良いか悪いかは別にしてCPANにある新しいモジュールのほとんどはこの記法で書かれています。この習慣にしたがっておいたほうがユーザに統一されたインターフェイスを提供できるという点で非常に多くの益があります。

変数の命名方法には別に記事を書いていますのでこちらも参考にしてください。
<a href="/blog/20081103122562.html">＜変数に適切な名前をつける＞</a>

サブルーチンの命名方法は原則として「動詞 + 名詞」です。意味がはっきりとわかるものについてはユーザの利便性を考えて「動詞」だけにしても良いかもしれません。ただし後で困ることがあるので「動詞 + 名詞」にしておくのが無難だと思います。

<h3>パッケージ変数には大文字とアンダーバーを使用する (強く推奨)</h3>

パッケージ変数には大文字とアンダーバーを使用します。

<pre>
our $OBJECT_COUNT;
our $CLASS_INFO;
</pre>

<h3>パッケージ変数は使わずにレキシカル変数を使うようにする (必須)</h3>

もしあなたがモジュールの作者でないのであればパッケージ変数を使う機会はありません。もし単体のスクリプトの中でパッケージ変数を使っているとしたらそれは間違った使い方です。myを使ったレキシカル変数に変更しましょう。

<h3>標準的(?)なコードのフォーマットで書く (少し推奨)</h3>

コードの書き方には好き嫌いがあるのですが、Perlベストプラクティスで紹介されている書き方やPerltidyと呼ばれるコード整形ツールが出力する形式にあわせておいたほうが幾分よいと思います。

サンプルとしてMojo::URLのソースコードのリンクを張っておきます。これをまねして書けば覚えられます。

<a href="http://github.com/kraih/mojo/blob/master/lib/Mojo/URL.pm">＜Mojo::URLのソースコード＞</a>

まねするポイントを少しだけ書いておきます。

<h4>1. ifやforeach文やサブルーチンなどのスペースの入る位置を見る</h4>
<pre>
# ifの直後にスペースがあって、()の中にはスペースがないなど
if ($flg) { 
  ...
}
</pre>

<h4>2. コメントの書き方やスペースの入れ方などを見る</h4>

コメントの書き方や行のスペースの入れ方などをみましょう。CPANに存在するほとんどのモジュールには親切なコメントがないのですが、個人的は簡潔なコメントをソースコードに書いてくれるとありがたいと思っています。

<h4>3. タブは使わないでインデントの幅はスペースで4(あるいは2)</h4>

一応これはPerlベストプラクティスでいわれていることです。(最近の僕はスペース2です)。またタブを使いたいという人も中にはいると思いますので、これは個人の好みで。

<h3>日本語などのマルチバイト文字を適切に扱うためにEncodeモジュールを使用する (強く推奨)</h3>

日本語などのマルチバイト文字を適切に扱うにはEncodeモジュールを使用します。こちらは記事にしましたのでリンクを張っておきます。

<a href="/blog/20091118124667.html">＜Encode 日本語などのマルチバイト文字列を適切に処理する＞</a>

古い解説にあるようなJcode.pmやJcode.plを使うような手法は現在では推奨できません。Perl5.8以降はEncodeモジュールを使用するのが標準的で問題が少ない方法です。

<h3>デフォルト変数 $_ は使用しない (強く推奨)</h3>

Perlにはデフォルト変数 $_ というものが存在します。デフォルト変数は関数に引数を指定しなかった場合に暗黙的に受け取る変数です。プログラムの中で使用すると可読性が落ちるので使うのは控えましょう。

デフォルト引数を使用するのは次の場合だけです。

<h4>1. ワンライナー</h4>

ワンライナーの中では使用してもよいと思います。printの引数や正規表現の対象として$_が利用されています。

<pre>
# AAAという文字を含む行を取り出すワンライナー
perl -ne "print if /AAA/";
</pre>

<h4>2. map関数とgrep関数と後置のfor</h4>

map関数やgrep関数や後置のforには$_ がわたってきますのでこれは利用せざるをえないです。

<pre>
my @greped_array = grep { $_ =~ /AAA/ } @array;
my @mapped_array = map  { $_ * 2 } @array;
print $_ for @array;
</pre>

有名なCPANモジュールの中にはデフォルト変数を使用しているものがありますが個人的には推奨しません。できるだけ明示的であったほうが可読性の高いプログラムになります。

<h3>foreach文ではレキシカル変数を宣言する (強く推奨)</h3>

Perl5ではforeach文の先頭でレキシカル変数を宣言することができます。

<pre>
my @students = ('taro', 'kenji', 'naoya');
for my $student (@students) {
  ...
}
</pre>

この例の場合は@studentsの各要素が$studentに入ってきます。$studentはレキシカル変数でforeachのブロックの先頭から終わりまでのスコープを持ちます。

レキシカル変数を省略するような書き方もできますが推奨しません。

<pre>
# 推奨できない書き方
for (@students) {
  ...
}
</pre>

<h3>コマンドライン引数の受け取りかた (参考)</h3>

<a href="/blog/20080108132865.html">コマンドライン引数</a>はこんな感じで受け取るのがよいです。

<pre>
# コマンドライン引数がひとつの場合
my $file = shift;
</pre>

<pre>
# コマンドライン引数が複数の場合
my ($file, $option) = @ARGV;
</pre>

<h3>サブルーチンの引数の受け取り方 (参考)</h3>

コマンドライン引数の場合と同様になります。

<pre>
# 引数がひとつの場合
sub func {
  my $file = shift;
}
</pre>

<pre>
# 引数が複数の場合
sub func {
  my ($file, $option) = @_;
}
</pre>

<h3>日付処理の標準モジュールを使用する (参考)</h3>

もしPerl5.10以降を使用しているならTime::Pieceというモジュールが標準で添付されており日付処理に使えます。

<a href="/blog/20091105124627.html">＜Time::Piece - 日付・時刻を扱うための標準モジュール＞</a>

またCPANからインストールできる環境であればDataTimeモジュールをインストールするのも良いかもしれません。こちらは高機能ですが少し重いです。

<a href="/blog/20090815124848.html">＜日付を汎用的に扱うモジュール DateTime＞</a>

それもできないならlocaltimeやTime::Localでがんばります。

<a href="/blog/20090809124848.html">＜Perlでの日付・時刻の扱い＞</a>

<h3>不必要なモジュールの読み込みは行わないこと (必須)</h3>

他のプログラムのソースコードをコピーしてきた場合にそのプログラムでは使用しないのに余計なモジュールが読み込まれている場合があります。これは後で読んだ人に対していらぬ誤解を招くので必ず削除するように心がけましょう。

<pre>
# 他のプログラムからソースコードをコピーしてきたために
# 不必要なモジュールの読み込みが残る場合があるので
# 気をつける
use File::Spec;
use File::Basename 'basename'; 
                               
</pre>

<h3>Perlのドキュメントの書き方 (参考)</h3>

仕事で使用する小さなスクリプトの場合はスクリプトの中にドキュメントを埋め込んでおくのがよいと思います。CPANモジュールの場合はソースコードの末尾がドキュメントになりますが、小さなスクリプトの場合は先頭に書いておくと利用者がソースコードを開いたときにぱっとみることができるので便利です。

PerlのドキュメントはPODと呼ばれる記法で書きます。簡単な書き方だけ紹介しておきます。「=head1」というのが見出しになります。「=head1」の右にタイトルを書きます。その下に一行あけて本文を書きます。一行あけるというのには意味があるので注意してください。ドキュメントの終わりは「=cut」という行になります。英語で書いた場合は次のようになります。

<pre>
=head1 SCRIPT NAME

SomeScript.pl

=head1 DESCRIPTION

This script is used to do ....

=head1 USAGE

perl SomeScript.pl file1 file2 ...

=cut

# ソースコードの始まり
use strict;
use warnings;

</pre>

ローカルなプロジェクトの場合は同僚にわかりやすく伝えるために日本語で書くのがよいと思います。

<pre>
=head1 スクリプト名

SomeScript.pl

=head1 概要

～するためのものです。

=head1 使用方法

perl SomeScript.pl file1 file2 ...

=cut

# ソースコードの始まり
use strict;
use warnings;

</pre>

<h3>コメントの#の嵐は避ける (推奨)</h3>

よく#だらけのコメントを仕事をしててみるのですが個人的にはお勧めしません。一番の理由は一度そのコメントの記述を行うと後から来た人がそれをまねしないといけないからです。関数ひとつ記述するのにこれをまねしないといけないのかと思うと気持ちが萎えます。またコードの品質を上げるどころか関数を書き換えたときにコメントが追いついていないということが頻繁に起きます。ですのでやめましょう。

<pre>
#################################################################
# 関数名     : ほにゃらら                                       #
# 引数       : 引数1 引数2                                      #
# 戻り値     : ほにゃらら                                       #
# 作成日時   : あああああ                                       #
# 作成者     : ほれほれ                                         #
# 関数の説明 : いいいいいい                                     #
# 更新履歴   : その1                                            #
#            : その2                                            #
#            : その3                                            #
#################################################################
sub func {
    
}
</pre>

こちらの書き方をお勧めします。
<pre>
# 簡単な解説(1行で)
sub func{
    
}
</pre>

<a href="http://github.com/kraih/mojo/blob/master/lib/Mojo/URL.pm">＜Mojo::URLのソースコード＞</a>
も参考にしてください。

<h3>文字列リスト演算子 (参考)</h3>

文字列リスト演算子はよく使用されるので解説しておきます。文字列リスト演算子は文字列の配列を作成するのによく利用されれます。

<pre>
my @strings = qw/aa bb cc/;
</pre>

次の記述と同じ意味があります。

<pre>
my @strings = ('aa', 'bb', 'cc');
</pre>

<h3>モジュールの関数をインポートするときは明示する (強く推奨)</h3>

モジュールで関数をインポートするときは明示するようにしたほうがよいでしょう。ソースコードを読んだ人がその関数はどのモジュールのものなのかを簡単に理解することができます。
<pre>
use File::Basename 'basename';
use File::Copy qw/copy move/;
use File::Path 'mkpath';
use Encode qw/encode decode/;

# mkpath関数を使用する。
mkpath $dir;
</pre>

もし明示的なインポートの記述がなかった場合はどうなるでしょう。

<pre>
use File::Basename;
use File::Copy;
use File::Path;
use Encode;

# これはどこからインポートされたかわからない 
mkpath $dir; 
</pre>

このような場合はuseされているすべてのモジュールのドキュメントを読むということになりかねません。あなたは関数がどのモジュールからインポートされたのかを知っているかもしれませんが、ソースコードを読む人には明示的ではありません。ですのでインポートする関数はどんなにあなたにとって明らかに思えても明示的に指定するようにしましょう。

(参考)<a href="/blog/20100409127089.html">File::Path</a>、<a href="/blog/20100408127089.html">File::Copy</a>

<h3>gotoは使用しない (本当に特別な場合を除いて必須)</h3>

Perlには<a href="/blog/20170514149606.html">goto文</a>がありますが使用してはいけません。gotoを使うプログラミングはPerlに限らずもう過去のものです。もしあなたが何らかの理由でgotoを使いたくなった場合代替する手段は必ず用意されていると思ってください。

ループ制御を行いたいなら「last」「next」を使用してください。エラー処理を行いたいならdieを使って例外を投げてください。

(gotoを使用しなければならない場面は、無限再帰呼び出しなどで、関数の階層を深くしたくないなどという本当に特殊な場合だけです。)

<h3>do ～ whileは使用しない (推奨)</h3>

do while文で記述できる文は<a href="/blog/20100123126425.html">while文</a>で必ず記述できます。do while文を使ったからといって記述が簡潔になるかといえばそうでもないです。逆に普段使用していない分だけ意図がわかりにくくなると感じます。

do while文で記述できる文はwhile文で必ず記述できるのでwhile文を使うロジックを考えることをお勧めします。

<h3>redoは使用しない (推奨)</h3>

Perlには<a href="/blog/20170515149615.html">redo文</a>がありますが、redoを使わなくても同じロジックを記述することができます。redoは何回か使用したことがあるのですが、redoを使ったプログラミングはとてもわかりにくくなると感じます。redoを使用しなくても同じロジックは必ず記述できるのでredoを使わないロジックを考えることをお勧めします。

<h3>プロトタイプは使用しない (強く推奨)</h3>

サブルーチンを定義するときにプロトタイプという型を指定できる機能がありますがこれは使用しません。

<pre>
# プロトタイプは使用しないこと
sub func ($@) {
  ...
}
</pre>

Perlでは明示的に型を指定しなくてもどのような型の引数も受け取れますし、引数の個数もいくつでもかまいません。ですのでプロトタイプで型を指定したり個数を指定したりする必要はまったくないのです。ですので必ずプロトタイプを指定しないサブルーチンの定義を行いましょう。

<pre>
sub func {
  ...    
}
</pre>

<h3>エラーを伝えるときはundefを戻り値として返却するのではなくdieを使用する。(推奨)</h3>

Perlには例外処理がないと思っている人もいるかもしれません。Javaのような例外オブジェクトというものはありませんが、簡潔な例外機構を備えています。

まずは旧来のエラー処理であった戻り値に<a href="/blog/20100220126425.html">undef</a>を返却する方法を見ます。エラーが発生したときに単独のreturnを記述するとスカラコンテキストの場合はundefがリストコンテキストの場合は空のリスト () が返却されます。

<pre>
# エラーが発生したときにundefを返却する
sub func {
  my $arg = shift;
  
  ...
  
  # エラー処理
  if ($error) {
    return; 
  }
  # エラーが起こらなかった場合の正しい値
  return $val;
}
</pre>
そして関数を呼び出す側でエラー処理を記述します。
<pre>
my $val = func();

# $valが偽値だったらプログラムを終了
die "Error" unless $val;
</pre>

この記述の問題点はfuncを使う人が戻り値のチェックを怠るとプログラムは先に進んでしまうということです。

ですので現在的なPerlではエラーを伝えるときにdieを使って例外を投げます。

<pre>
# エラーが発生したときにdieを使って例外を投げる
sub func {
  my $arg = shift;
  
  # なんらかの処理
  
  # dieを使って例外を投げる
  if ($error) {
    die "Error message";
  }

  # エラーが起こらなかった場合の正しい値
  return $val;
}
</pre>

このようにするとfuncを呼び出してエラーが発生したときはエラーメッセージを表示してプログラムは終了します。

<pre>
# エラーが発生した場合はエラーメッセージを表示してプログラムが終了
func(); 
</pre>

プログラムを終了させたくない場合は<a href="/blog/20100312126967.html">evalブロック</a>で受けます。これはJavaでいうcatchだと思ってください。エラーが発生した場合は$@という特殊変数にエラーの内容が設定されますので、この変数をチェックすることでエラーが発生したかどうかを調べることができます。

<pre>
eval { func() };

if ($@) {
  # エラーが発生した場合の処理を記述
}
</pre>

<h3>コンストラクタの呼び出しではアロー演算子を利用する</h3>

コンストラクタの呼び出しはアロー演算子を使用するのがよいでしょう。Perlではコンストラクタと他のメソッドに実質的な違いはありません。

<pre>
my $obj = SomeClass->new;
</pre>

間接オブジェクト呼び出しは、将来的には非推奨になる可能性があります。

<pre>
# 間接オブジェクト呼び出し
my $obj = new SomeClass();
</pre>

