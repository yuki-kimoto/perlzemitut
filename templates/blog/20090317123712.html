<ol class="bread" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemprop="item" href="/">
        <span itemprop="name">Perl</span></a>
    <meta itemprop="position" content="1" />
  </li>
  &#8250;
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemprop="item" href="/blog/20161030147778.html">
      <span itemprop="name">オブジェクト指向</span></a>
    <meta itemprop="position" content="2" />
  </li>
  &#8250;
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
      <span itemprop="name">コンストラクタの作成</span>
    <meta itemprop="position" content="3" />
  </li>
</ol>
<h2>コンストラクタ</h2>



前回は以下のようなクラスの雛形を作成しました。

<pre>
package Book;

sub new { # コンストラクタの実装 }

sub title { # アクセッサの実装 }
sub author { # アクセッサの実装 }

</pre>

<h3>1. コンストラクタとは</h3>

<b>オブジェクトはクラスを元に生成</b>されます。オブジェクトとは何かとかクラスとは何かということは少し忘れて、「オブジェクトはクラスを元に生成される」ということを覚えてください。

そしてコンストラクタとはオブジェクトを生成するメソッドのことです。コンストラクタを作成すれば

<pre>
my $book = Book->new;
</pre>

という記述でオブジェクトを作成できるようになります。

コンストラクタ名には慣習的に<b>new</b>という名前が使用されます。ですが、コンストラクタはnewという名前に必ずしましょう(なぜならあなたのモジュールを使う人はコンストラクタ名がnewであることを期待するからです)

<h3>2. 一番簡単なコンストラクタの実装</h3>

ではコンストラクタを実装してみましょう。以下が一番簡単なコンストラクタの実装になります。でも一番簡単といっても少し難しいのです。

<pre>
sub new { 
    my $class = shift;
    my $self = {};
    return bless $self, $class;
}
</pre>

以下の呼び出し

<pre>
my $book = Book->new;
</pre>

を行ったとき、 $class には、何が代入されるでしょうか?

答えは、<b>Book</b> です。コンストラクタnewは第1引数として<b>クラス名</b>を受け取ります。

<h3>3. ハッシュのリファレンスを準備する</h3>

<pre>
  my $self = {};
</pre>

の行は何をしているのでしょうか?

実はこれは<b>オブジェクトが所有するデータ</b>なのです。重要なのでもう一度いいます。<b>オブジェクトはデータを所有</b>します。そして、一般的には、<b>ハッシュのリファレンス</b>がデータとして選択されます。

(本当に本当のことをいえば、オブジェクトはデータそのものです。ややこしくならないために最初はオブジェクトはデータを所有すると覚えてください。)

<h3>4. データとクラスを結びつける</h3>

最後の行

<pre>
return bless $self, $class;
</pre>

には、bless という関数があります。

bless関数は、第1引数にデータ、第2引数にクラス名を受け取って、データとクラスを結び付けます。

オブジェクトは、<b>データとクラスを結びつけ</b>て生み出されるのです。そして、結びつけたものを呼び出しもとに返却してあげます。

<h3>5. Perlでのオブジェクトとは何か?</h3>

Perlのオブジェクトとは、<b>クラスに結び付けられたデータ</b>のことです。それ以上の意味もそれ以下の意味もありません。

そしてこのように作ったオブジェクトは、他の言語で使用されるオブジェクトと遜色ない機能を発揮します。

<h2>コンストラクタに引数を渡せるようにする</h2>



今回は、コンストラクタに引数を渡せるようにしてみましょう。

<h3>1. コンストラクタに引数を渡す。</h3>
オブジェクトを作成するときは
<pre>
my $book = Book->new(title => 'Good news', author => 'Kimoto');
</pre>

という形が理想的です。

このような機能を持つコンストラクタを作成してみましょう。

<pre>
sub new {
  my ($class, %args) = @_;
  my $self = {%args};
  return $self, $class;
}
</pre>

特に難しい部分はありませんね。

<h3>2. ハッシュのリファレンスも受け入れたい</h3>

ハッシュを受け入れられると同時に<b>ハッシュのリファレンス</b>も受け入れたいと思うところでしょう。こんな感じに。

<pre>
my $book = Book->new({title => 'Good news', author => 'Kimoto'});
</pre>

対応できるコンストラクタは、こんな感じです。

<pre>
sub new{
    my ($class, @args) = @_;
    my %args = ref $args[0] eq 'HASH' ? %{ $args[0] } : @args;
    my $self = {%args};
    return $self, $class;
}
</pre>

第1引数が、ハッシュリファレンスだった場合は、それをデリファレンスしてハッシュに代入しますそうでない場合は、引数をハッシュとして代入します。

<h3>3. コンストラクタにデフォルト値を設定したい</h3>

さてさて、コンストラクタに対する要求はまだまだ続きます。値が代入されない場合の<b>デフォルト値を設定</b>したい場合などです。

<pre>
sub new {
  my ( $class, @args ) = @_;
  my %args = ref $args[0] eq 'HASH' ? %{$args[0]} : @args;
  my $self = {%args};
 
  $self->{title} ||= 'default title';
  $self->{author} ||= 'default author';

  return $self, $class;
}
</pre>

以下の部分に注目してください。<b>値が偽値ならば、デフォルト値を代入</b>するという操作をしています。

<pre>
  $self->{ title } ||= 'default title';
  $self->{ author } ||= 'default author';
</pre>

でもこれじゃ、空文字を代入された場合もデフォルト値が設定されてしまいますので、それがまずい場合は、<b>defined</b> 関数を使用して

<pre>
  $self->{ title } = 'default title' unless defined $self->{ title };
</pre>

とします。

</ol>
<h2>汎用的なコンストラクタの雛形</h2>



汎用的なコンストラクタの雛形を提示しておきます。汎用的なコンストラクタの雛形はちょっと難しいです。

<h3>1. 汎用的なコンストラクタの指針</h3>

汎用的なコンストラクタは、クラスから呼ばれたときだけではなくて、<b>オブジェクトから呼び出された場合も考慮に入れる</b>必要があります。

クラスから呼ばれた場合と

<pre>
my $book = Book->new;
</pre>

オブジェクトから呼ばれた場合の

<pre>
my $book2 = $book->new
</pre>

の両方に対応する。

またもうひとつの指針として、コンストラクタと初期化処理は分離するということが挙げられます。<b>初期化用のinitメソッド</b>を作成してあげます。

<h3>2. 汎用的なコンストラクタの作成</h3>
以下が汎用的なコンストラクタの雛形です。
<pre>
sub new {
  my $proto = shift;
  my $class = ref $proto || $proto;
  my $self = {};
  bless $self, $class;
  
  $self->init(@_);
  return $self;
}

sub init {
  my ($self, @args) = @_;
  # 追加で行いたい処理
}
</pre>

<h3>3. オブジェクトからクラス名を取り出す処理</h3>

この部分がわかりにくいと思います。
<pre>
  my $proto = shift;
  my $class = ref $proto || $proto;　
</pre>
これは何をやっているかというと、$proto がオブジェクトだった場合には、<a href="/blog/20090318123712.html">ref関数</a>を使って関連付けられているクラス名を取り出します。

そうでない場合は、クラス名をそのまま使用するということをやっています。<a href="/blog/20090318123712.html">ref関数</a>に文字列(クラス名)が渡された場合は、偽値が返るので、|| の右側が実行されます。

そういうわけで、クラス名から呼ばれても、オブジェクトから呼ばれても、$classにはクラス名が入ることになります。

<h3>4. 初期化処理を分離する</h3>

初期化処理を分離しているのが以下の部分です。初期化を行う場合は、bless 関数で先にオブジェクトを作成しておいてあげます。そしてそのオブジェクトから、initメソッドを呼び出します。

ちょっとわかりにくいですが、慣れましょう。同じクラスのメソッドを呼び出すには、オブジェクトつまり、bless された $self から呼び出す必要があるのです。

<pre>
  my $self = {};
  bless $self, $class;
  $self->init(@_);
</pre>

<h3>5. なぜこのように作成する必要があるのか?</h3>

それはきちんとはまだいいません。継承のところで取り上げることにします。このようにオブジェクトを作成しておかないと、継承をしようとしたときに面倒な問題が発生するとだけいっておきます。

